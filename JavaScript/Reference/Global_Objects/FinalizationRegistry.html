<!DOCTYPE html><html lang="en-US" prefix="og: https://ogp.me/ns#"><!-- Mirrored from developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/FinalizationRegistry by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 08 Jan 2025 13:04:29 GMT --><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="icon" href="https://developer.mozilla.org/favicon-48x48.bc390275e955dacb2e65.png"><link rel="apple-touch-icon" href="https://developer.mozilla.org/apple-touch-icon.528534bba673c38049c2.png"><meta name="theme-color" content="#ffffff"><link rel="manifest" href="https://developer.mozilla.org/manifest.f42880861b394dd4dc9b.json"><link rel="search" type="application/opensearchdescription+xml" href="https://developer.mozilla.org/opensearch.xml" title="MDN Web Docs"><title>FinalizationRegistry</title><link rel="alternate" title="FinalizationRegistry" href="https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/FinalizationRegistry" hreflang="de"><link rel="alternate" title="FinalizationRegistry" href="https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Global_Objects/FinalizationRegistry" hreflang="fr"><link rel="alternate" title="FinalizationRegistry" href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/FinalizationRegistry" hreflang="ja"><link rel="alternate" title="FinalizationRegistry" href="FinalizationRegistry.html" hreflang="en"><link rel="preload" as="font" type="font/woff2" href="https://developer.mozilla.org/static/media/Inter.var.c2fe3cb2b7c746f7966a.woff2" crossorigin=""><link rel="alternate" type="application/rss+xml" title="MDN Blog RSS Feed" href="https://developer.mozilla.org/en-US/blog/rss.xml" hreflang="en"><meta name="description" content="A FinalizationRegistry object lets you request a callback when a value is garbage-collected."><meta property="og:url" content="FinalizationRegistry.html"><meta property="og:title" content="FinalizationRegistry - JavaScript | MDN"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:description" content="A FinalizationRegistry object lets you request a callback when a value is garbage-collected."><meta property="og:image" content="https://developer.mozilla.org/mdn-social-share.d893525a4fb5fb1f67a2.png"><meta property="og:image:type" content="image/png"><meta property="og:image:height" content="1080"><meta property="og:image:width" content="1920"><meta property="og:image:alt" content="The MDN Web Docs logo, featuring a blue accent color, displayed on a solid black background."><meta property="og:site_name" content="MDN Web Docs"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:creator" content="MozDevNet"><link rel="canonical" href="FinalizationRegistry.html"><style media="print">.article-actions-container,.document-toc-container,.language-menu,.main-menu-toggle,.on-github,.page-footer,.place,.sidebar,.top-banner,.top-navigation-main,ul.prev-next{display:none!important}.main-page-content,.main-page-content pre{padding:2px}.main-page-content pre{border-left-width:2px}</style><link href="https://developer.mozilla.org/static/css/main.65aa8eed.css" rel="stylesheet"></head><body><script>if(document.body.addEventListener("load",(t=>{t.target.classList.contains("interactive")&&t.target.setAttribute("data-readystate","complete")}),{capture:!0}),window&&document.documentElement){const t={light:"#ffffff",dark:"#1b1b1b"};try{const e=window.localStorage.getItem("theme");e&&(document.documentElement.className=e,document.documentElement.style.backgroundColor=t[e]);const o=window.localStorage.getItem("nop");o&&(document.documentElement.dataset.nop=o)}catch(t){console.warn("Unable to read theme from localStorage",t)}}</script><div id="root"><div class="page-wrapper  category-javascript document-page"><div class="main-wrapper"><main id="content" class="main-content  "><article class="main-page-content" lang="en-US"><header><h1>FinalizationRegistry</h1><details class="baseline-indicator high"><summary><span class="indicator" role="img" aria-label="Baseline Check"></span><h2>Baseline<!-- --> <span class="not-bold">Widely available</span></h2><div class="browsers"><span class="engine" title="Supported in Chrome and Edge"><span class="browser chrome supported" role="img" aria-label="Chrome check"></span><span class="browser edge supported" role="img" aria-label="Edge check"></span></span><span class="engine" title="Supported in Firefox"><span class="browser firefox supported" role="img" aria-label="Firefox check"></span></span><span class="engine" title="Supported in Safari"><span class="browser safari supported" role="img" aria-label="Safari check"></span></span></div><span class="icon icon-chevron "></span></summary><div class="extra"><p>This feature is well established and works across many devices and browser versions. It’s been available across browsers since<!-- --> <!-- -->April 2021<!-- -->.</p><ul><li><a href="https://developer.mozilla.org/en-US/docs/Glossary/Baseline/Compatibility" data-glean="baseline_link_learn_more" target="_blank" class="learn-more">Learn more</a></li><li><a href="#browser_compatibility" data-glean="baseline_link_bcd_table">See full compatibility</a></li><li><a href="https://survey.alchemer.com/s3/7634825/MDN-baseline-feedback?page=%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FFinalizationRegistry&amp;level=high" data-glean="baseline_link_feedback" class="feedback-link" target="_blank" rel="noreferrer">Report feedback</a></li></ul></div></details></header><div class="section-content"><p>A <strong><code>FinalizationRegistry</code></strong> object lets you request a callback when a value is garbage-collected.</p></div><section aria-labelledby="description"><h2 id="description"><a href="#description">Description</a></h2><div class="section-content"><p><code>FinalizationRegistry</code> provides a way to request that a <em>cleanup callback</em> get called at some point when a value registered with the registry has been <em>reclaimed</em> (garbage-collected). (Cleanup callbacks are sometimes called <em>finalizers</em>.)</p>
<div class="notecard note">
<p><strong>Note:</strong>
Cleanup callbacks should not be used for essential program logic. See <a href="#notes_on_cleanup_callbacks">Notes on cleanup callbacks</a> for details.</p>
</div>
<p>You create the registry passing in the callback:</p>
<div class="code-example"><div class="example-header"><span class="language-name">js</span></div><pre class="brush: js notranslate"><code>const registry = new FinalizationRegistry((heldValue) =&gt; {
  // …
});
</code></pre></div>
<p>Then you register any value you want a cleanup callback for by calling the <code>register</code> method, passing in the value and a <em>held value</em> for it:</p>
<div class="code-example"><div class="example-header"><span class="language-name">js</span></div><pre class="brush: js notranslate"><code>registry.register(target, "some value");
</code></pre></div>
<p>The registry does not keep a strong reference to the value, as that would defeat the purpose (if the registry held it strongly, the value would never be reclaimed). In JavaScript, objects and <a href="Symbol.html#shared_symbols_in_the_global_symbol_registry">non-registered symbols</a> are garbage collectable, so they can be registered in a <code>FinalizationRegistry</code> object as the target or the token.</p>
<p>If <code>target</code> is reclaimed, your cleanup callback may be called at some point with the <em>held value</em> you provided for it (<code>"some value"</code> in the above). The held value can be any value you like: a primitive or an object, even <code>undefined</code>. If the held value is an object, the registry keeps a <em>strong</em> reference to it (so it can pass it to your cleanup callback later).</p>
<p>If you might want to unregister a registered target value later, you pass a third value, which is the <em>unregistration token</em> you'll use later when calling the registry's <code>unregister</code> function to unregister the value. The registry only keeps a weak reference to the unregister token.</p>
<p>It's common to use the target value itself as the unregister token, which is just fine:</p>
<div class="code-example"><div class="example-header"><span class="language-name">js</span></div><pre class="brush: js notranslate"><code>registry.register(target, "some value", target);
// …

// some time later, if you don't care about `target` anymore, unregister it
registry.unregister(target);
</code></pre></div>
<p>It doesn't have to be the same value, though; it can be a different one:</p>
<div class="code-example"><div class="example-header"><span class="language-name">js</span></div><pre class="brush: js notranslate"><code>registry.register(target, "some value", token);
// …

// some time later
registry.unregister(token);
</code></pre></div></div></section><section aria-labelledby="avoid_where_possible"><h3 id="avoid_where_possible"><a href="#avoid_where_possible">Avoid where possible</a></h3><div class="section-content"><p>Correct use of <code>FinalizationRegistry</code> takes careful thought, and it's best avoided if possible. It's also important to avoid relying on any specific behaviors not guaranteed by the specification. When, how, and whether garbage collection occurs is down to the implementation of any given JavaScript engine. Any behavior you observe in one engine may be different in another engine, in another version of the same engine, or even in a slightly different situation with the same version of the same engine. Garbage collection is a hard problem that JavaScript engine implementers are constantly refining and improving their solutions to.</p>
<p>Here are some specific points included by the authors in the <a href="https://github.com/tc39/proposal-weakrefs" class="external" target="_blank">proposal</a> that introduced <code>FinalizationRegistry</code>:</p>
<blockquote>
<p><a href="https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)" class="external" target="_blank">Garbage collectors</a> are complicated. If an application or library depends on GC cleaning up a WeakRef or calling a finalizer [cleanup callback] in a timely, predictable manner, it's likely to be disappointed: the cleanup may happen much later than expected, or not at all. Sources of variability include:</p>
<ul>
<li>One object might be garbage-collected much sooner than another object, even if they become unreachable at the same time, e.g., due to generational collection.</li>
<li>Garbage collection work can be split up over time using incremental and concurrent techniques.</li>
<li>Various runtime heuristics can be used to balance memory usage, responsiveness.</li>
<li>The JavaScript engine may hold references to things which look like they are unreachable (e.g., in closures, or inline caches).</li>
<li>Different JavaScript engines may do these things differently, or the same engine may change its algorithms across versions.</li>
<li>Complex factors may lead to objects being held alive for unexpected amounts of time, such as use with certain APIs.</li>
</ul>
</blockquote></div></section><section aria-labelledby="notes_on_cleanup_callbacks"><h3 id="notes_on_cleanup_callbacks"><a href="#notes_on_cleanup_callbacks">Notes on cleanup callbacks</a></h3><div class="section-content"><ul>
<li>Developers shouldn't rely on cleanup callbacks for essential program logic. Cleanup callbacks may be useful for reducing memory usage across the course of a program, but are unlikely to be useful otherwise.</li>
<li>If your code has just registered a value to the registry, that target will not be reclaimed until the end of the current JavaScript <a href="https://tc39.es/ecma262/multipage/executable-code-and-execution-contexts.html#job" class="external" target="_blank">job</a>. See <a href="WeakRef.html#notes_on_weakrefs">notes on WeakRefs</a> for details.</li>
<li>A conforming JavaScript implementation, even one that does garbage collection, is not required to call cleanup callbacks. When and whether it does so is entirely down to the implementation of the JavaScript engine. When a registered object is reclaimed, any cleanup callbacks for it may be called then, or some time later, or not at all.</li>
<li>It's likely that major implementations will call cleanup callbacks at some point during execution, but those calls may be substantially after the related object was reclaimed. Furthermore, if there is an object registered in two registries, there is no guarantee that the two callbacks are called next to each other — one may be called and the other never called, or the other may be called much later.</li>
<li>There are also situations where even implementations that normally call cleanup callbacks are unlikely to call them:
<ul>
<li>When the JavaScript program shuts down entirely (for instance, closing a tab in a browser).</li>
<li>When the <code>FinalizationRegistry</code> instance itself is no longer reachable by JavaScript code.</li>
</ul>
</li>
<li>If the target of a <code>WeakRef</code> is also in a <code>FinalizationRegistry</code>, the <code>WeakRef</code>'s target is cleared at the same time or before any cleanup callback associated with the registry is called; if your cleanup callback calls <code>deref</code> on a <code>WeakRef</code> for the object, it will receive <code>undefined</code>.</li>
</ul></div></section><section aria-labelledby="constructor"><h2 id="constructor"><a href="#constructor">Constructor</a></h2><div class="section-content"><dl>
<dt id="finalizationregistry"><a href="FinalizationRegistry/FinalizationRegistry.html"><code>FinalizationRegistry()</code></a></dt>
<dd>
<p>Creates a new <code>FinalizationRegistry</code> object.</p>
</dd>
</dl></div></section><section aria-labelledby="instance_properties"><h2 id="instance_properties"><a href="#instance_properties">Instance properties</a></h2><div class="section-content"><p>These properties are defined on <code>FinalizationRegistry.prototype</code> and shared by all <code>FinalizationRegistry</code> instances.</p>
<dl>
<dt id="finalizationregistry.prototype.constructor"><a href="Object/constructor.html"><code>FinalizationRegistry.prototype.constructor</code></a></dt>
<dd>
<p>The constructor function that created the instance object. For <code>FinalizationRegistry</code> instances, the initial value is the <a href="FinalizationRegistry/FinalizationRegistry.html"><code>FinalizationRegistry</code></a> constructor.</p>
</dd>
<dt id="finalizationregistry.prototypesymbol.tostringtag"><a href="#finalizationregistry.prototypesymbol.tostringtag"><code>FinalizationRegistry.prototype[Symbol.toStringTag]</code></a></dt>
<dd>
<p>The initial value of the <a href="Symbol/toStringTag.html"><code>[Symbol.toStringTag]</code></a> property is the string <code>"FinalizationRegistry"</code>. This property is used in <a href="Object/toString.html"><code>Object.prototype.toString()</code></a>.</p>
</dd>
</dl></div></section><section aria-labelledby="instance_methods"><h2 id="instance_methods"><a href="#instance_methods">Instance methods</a></h2><div class="section-content"><dl>
<dt id="finalizationregistry.prototype.register"><a href="FinalizationRegistry/register.html"><code>FinalizationRegistry.prototype.register()</code></a></dt>
<dd>
<p>Registers an object with the registry in order to get a cleanup callback when/if the object is garbage-collected.</p>
</dd>
<dt id="finalizationregistry.prototype.unregister"><a href="FinalizationRegistry/unregister.html"><code>FinalizationRegistry.prototype.unregister()</code></a></dt>
<dd>
<p>Unregisters an object from the registry.</p>
</dd>
</dl></div></section><section aria-labelledby="examples"><h2 id="examples"><a href="#examples">Examples</a></h2><div class="section-content"></div></section><section aria-labelledby="creating_a_new_registry"><h3 id="creating_a_new_registry"><a href="#creating_a_new_registry">Creating a new registry</a></h3><div class="section-content"><p>You create the registry passing in the callback:</p>
<div class="code-example"><div class="example-header"><span class="language-name">js</span></div><pre class="brush: js notranslate"><code>const registry = new FinalizationRegistry((heldValue) =&gt; {
  // …
});
</code></pre></div></div></section><section aria-labelledby="registering_objects_for_cleanup"><h3 id="registering_objects_for_cleanup"><a href="#registering_objects_for_cleanup">Registering objects for cleanup</a></h3><div class="section-content"><p>Then you register any objects you want a cleanup callback for by calling the <code>register</code> method, passing in the object and a <em>held value</em> for it:</p>
<div class="code-example"><div class="example-header"><span class="language-name">js</span></div><pre class="brush: js notranslate"><code>registry.register(theObject, "some value");
</code></pre></div></div></section><section aria-labelledby="callbacks_never_called_synchronously"><h3 id="callbacks_never_called_synchronously"><a href="#callbacks_never_called_synchronously">Callbacks never called synchronously</a></h3><div class="section-content"><p>No matter how much pressure you put on the garbage collector, the cleanup callback will never be called synchronously. The object may be reclaimed synchronously, but the callback will always be called sometime after the current job finishes:</p>
<div class="code-example"><div class="example-header"><span class="language-name">js</span></div><pre class="brush: js notranslate"><code>let counter = 0;
const registry = new FinalizationRegistry(() =&gt; {
  console.log(`Array gets garbage collected at ${counter}`);
});

registry.register(["foo"]);

(function allocateMemory() {
  // Allocate 50000 functions — a lot of memory!
  Array.from({ length: 50000 }, () =&gt; () =&gt; {});
  if (counter &gt; 5000) return;
  counter++;
  allocateMemory();
})();

console.log("Main job ends");
// Logs:
// Main job ends
// Array gets garbage collected at 5001
</code></pre></div>
<p>However, if you allow a little break between each allocation, the callback may be called sooner:</p>
<div class="code-example"><div class="example-header"><span class="language-name">js</span></div><pre class="brush: js notranslate"><code>let arrayCollected = false;
let counter = 0;
const registry = new FinalizationRegistry(() =&gt; {
  console.log(`Array gets garbage collected at ${counter}`);
  arrayCollected = true;
});

registry.register(["foo"]);

(function allocateMemory() {
  // Allocate 50000 functions — a lot of memory!
  Array.from({ length: 50000 }, () =&gt; () =&gt; {});
  if (counter &gt; 5000 || arrayCollected) return;
  counter++;
  // Use setTimeout to make each allocateMemory a different job
  setTimeout(allocateMemory);
})();

console.log("Main job ends");
</code></pre></div>
<p>There's no guarantee that the callback will be called sooner or if it will be called at all, but there's a possibility that the logged message has a counter value smaller than 5000.</p></div></section><h2 id="specifications"><a href="#specifications">Specifications</a></h2><table class="standard-table"><thead><tr><th scope="col">Specification</th></tr></thead><tbody><tr><td><a href="https://tc39.es/ecma262/multipage/managing-memory.html#sec-finalization-registry-objects">ECMAScript Language Specification<!-- --> <br><small># <!-- -->sec-finalization-registry-objects</small></a></td></tr></tbody></table><h2 id="browser_compatibility"><a href="#browser_compatibility">Browser compatibility</a></h2><p>BCD tables only load in the browser<noscript> <!-- -->with JavaScript enabled. Enable JavaScript to view data.</noscript></p><section aria-labelledby="see_also"><h2 id="see_also"><a href="#see_also">See also</a></h2><div class="section-content"><ul>
<li><a href="WeakRef.html"><code>WeakRef</code></a></li>
<li><a href="WeakSet.html"><code>WeakSet</code></a></li>
<li><a href="WeakMap.html"><code>WeakMap</code></a></li>
</ul></div></section></article></main></div></div></div><script type="application/json" id="hydration">{"url":"/en-US/docs/Web/JavaScript/Reference/Global_Objects/FinalizationRegistry","doc":{"body":[{"type":"prose","value":{"id":null,"title":null,"isH3":false,"content":"<p>A <strong><code>FinalizationRegistry</code></strong> object lets you request a callback when a value is garbage-collected.</p>"}},{"type":"prose","value":{"id":"description","title":"Description","isH3":false,"content":"<p><code>FinalizationRegistry</code> provides a way to request that a <em>cleanup callback</em> get called at some point when a value registered with the registry has been <em>reclaimed</em> (garbage-collected). (Cleanup callbacks are sometimes called <em>finalizers</em>.)</p>\n<div class=\"notecard note\">\n<p><strong>Note:</strong>\nCleanup callbacks should not be used for essential program logic. See <a href=\"#notes_on_cleanup_callbacks\">Notes on cleanup callbacks</a> for details.</p>\n</div>\n<p>You create the registry passing in the callback:</p>\n<div class=\"code-example\"><div class=\"example-header\"><span class=\"language-name\">js</span></div><pre class=\"brush: js notranslate\"><code>const registry = new FinalizationRegistry((heldValue) =&gt; {\n  // …\n});\n</code></pre></div>\n<p>Then you register any value you want a cleanup callback for by calling the <code>register</code> method, passing in the value and a <em>held value</em> for it:</p>\n<div class=\"code-example\"><div class=\"example-header\"><span class=\"language-name\">js</span></div><pre class=\"brush: js notranslate\"><code>registry.register(target, \"some value\");\n</code></pre></div>\n<p>The registry does not keep a strong reference to the value, as that would defeat the purpose (if the registry held it strongly, the value would never be reclaimed). In JavaScript, objects and <a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol#shared_symbols_in_the_global_symbol_registry\">non-registered symbols</a> are garbage collectable, so they can be registered in a <code>FinalizationRegistry</code> object as the target or the token.</p>\n<p>If <code>target</code> is reclaimed, your cleanup callback may be called at some point with the <em>held value</em> you provided for it (<code>\"some value\"</code> in the above). The held value can be any value you like: a primitive or an object, even <code>undefined</code>. If the held value is an object, the registry keeps a <em>strong</em> reference to it (so it can pass it to your cleanup callback later).</p>\n<p>If you might want to unregister a registered target value later, you pass a third value, which is the <em>unregistration token</em> you'll use later when calling the registry's <code>unregister</code> function to unregister the value. The registry only keeps a weak reference to the unregister token.</p>\n<p>It's common to use the target value itself as the unregister token, which is just fine:</p>\n<div class=\"code-example\"><div class=\"example-header\"><span class=\"language-name\">js</span></div><pre class=\"brush: js notranslate\"><code>registry.register(target, \"some value\", target);\n// …\n\n// some time later, if you don't care about `target` anymore, unregister it\nregistry.unregister(target);\n</code></pre></div>\n<p>It doesn't have to be the same value, though; it can be a different one:</p>\n<div class=\"code-example\"><div class=\"example-header\"><span class=\"language-name\">js</span></div><pre class=\"brush: js notranslate\"><code>registry.register(target, \"some value\", token);\n// …\n\n// some time later\nregistry.unregister(token);\n</code></pre></div>"}},{"type":"prose","value":{"id":"avoid_where_possible","title":"Avoid where possible","isH3":true,"content":"<p>Correct use of <code>FinalizationRegistry</code> takes careful thought, and it's best avoided if possible. It's also important to avoid relying on any specific behaviors not guaranteed by the specification. When, how, and whether garbage collection occurs is down to the implementation of any given JavaScript engine. Any behavior you observe in one engine may be different in another engine, in another version of the same engine, or even in a slightly different situation with the same version of the same engine. Garbage collection is a hard problem that JavaScript engine implementers are constantly refining and improving their solutions to.</p>\n<p>Here are some specific points included by the authors in the <a href=\"https://github.com/tc39/proposal-weakrefs\" class=\"external\" target=\"_blank\">proposal</a> that introduced <code>FinalizationRegistry</code>:</p>\n<blockquote>\n<p><a href=\"https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)\" class=\"external\" target=\"_blank\">Garbage collectors</a> are complicated. If an application or library depends on GC cleaning up a WeakRef or calling a finalizer [cleanup callback] in a timely, predictable manner, it's likely to be disappointed: the cleanup may happen much later than expected, or not at all. Sources of variability include:</p>\n<ul>\n<li>One object might be garbage-collected much sooner than another object, even if they become unreachable at the same time, e.g., due to generational collection.</li>\n<li>Garbage collection work can be split up over time using incremental and concurrent techniques.</li>\n<li>Various runtime heuristics can be used to balance memory usage, responsiveness.</li>\n<li>The JavaScript engine may hold references to things which look like they are unreachable (e.g., in closures, or inline caches).</li>\n<li>Different JavaScript engines may do these things differently, or the same engine may change its algorithms across versions.</li>\n<li>Complex factors may lead to objects being held alive for unexpected amounts of time, such as use with certain APIs.</li>\n</ul>\n</blockquote>"}},{"type":"prose","value":{"id":"notes_on_cleanup_callbacks","title":"Notes on cleanup callbacks","isH3":true,"content":"<ul>\n<li>Developers shouldn't rely on cleanup callbacks for essential program logic. Cleanup callbacks may be useful for reducing memory usage across the course of a program, but are unlikely to be useful otherwise.</li>\n<li>If your code has just registered a value to the registry, that target will not be reclaimed until the end of the current JavaScript <a href=\"https://tc39.es/ecma262/multipage/executable-code-and-execution-contexts.html#job\" class=\"external\" target=\"_blank\">job</a>. See <a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakRef#notes_on_weakrefs\">notes on WeakRefs</a> for details.</li>\n<li>A conforming JavaScript implementation, even one that does garbage collection, is not required to call cleanup callbacks. When and whether it does so is entirely down to the implementation of the JavaScript engine. When a registered object is reclaimed, any cleanup callbacks for it may be called then, or some time later, or not at all.</li>\n<li>It's likely that major implementations will call cleanup callbacks at some point during execution, but those calls may be substantially after the related object was reclaimed. Furthermore, if there is an object registered in two registries, there is no guarantee that the two callbacks are called next to each other — one may be called and the other never called, or the other may be called much later.</li>\n<li>There are also situations where even implementations that normally call cleanup callbacks are unlikely to call them:\n<ul>\n<li>When the JavaScript program shuts down entirely (for instance, closing a tab in a browser).</li>\n<li>When the <code>FinalizationRegistry</code> instance itself is no longer reachable by JavaScript code.</li>\n</ul>\n</li>\n<li>If the target of a <code>WeakRef</code> is also in a <code>FinalizationRegistry</code>, the <code>WeakRef</code>'s target is cleared at the same time or before any cleanup callback associated with the registry is called; if your cleanup callback calls <code>deref</code> on a <code>WeakRef</code> for the object, it will receive <code>undefined</code>.</li>\n</ul>"}},{"type":"prose","value":{"id":"constructor","title":"Constructor","isH3":false,"content":"<dl>\n<dt id=\"finalizationregistry\"><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/FinalizationRegistry/FinalizationRegistry\"><code>FinalizationRegistry()</code></a></dt>\n<dd>\n<p>Creates a new <code>FinalizationRegistry</code> object.</p>\n</dd>\n</dl>"}},{"type":"prose","value":{"id":"instance_properties","title":"Instance properties","isH3":false,"content":"<p>These properties are defined on <code>FinalizationRegistry.prototype</code> and shared by all <code>FinalizationRegistry</code> instances.</p>\n<dl>\n<dt id=\"finalizationregistry.prototype.constructor\"><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/constructor\"><code>FinalizationRegistry.prototype.constructor</code></a></dt>\n<dd>\n<p>The constructor function that created the instance object. For <code>FinalizationRegistry</code> instances, the initial value is the <a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/FinalizationRegistry/FinalizationRegistry\"><code>FinalizationRegistry</code></a> constructor.</p>\n</dd>\n<dt id=\"finalizationregistry.prototypesymbol.tostringtag\"><a href=\"#finalizationregistry.prototypesymbol.tostringtag\"><code>FinalizationRegistry.prototype[Symbol.toStringTag]</code></a></dt>\n<dd>\n<p>The initial value of the <a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/toStringTag\"><code>[Symbol.toStringTag]</code></a> property is the string <code>\"FinalizationRegistry\"</code>. This property is used in <a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/toString\"><code>Object.prototype.toString()</code></a>.</p>\n</dd>\n</dl>"}},{"type":"prose","value":{"id":"instance_methods","title":"Instance methods","isH3":false,"content":"<dl>\n<dt id=\"finalizationregistry.prototype.register\"><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/FinalizationRegistry/register\"><code>FinalizationRegistry.prototype.register()</code></a></dt>\n<dd>\n<p>Registers an object with the registry in order to get a cleanup callback when/if the object is garbage-collected.</p>\n</dd>\n<dt id=\"finalizationregistry.prototype.unregister\"><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/FinalizationRegistry/unregister\"><code>FinalizationRegistry.prototype.unregister()</code></a></dt>\n<dd>\n<p>Unregisters an object from the registry.</p>\n</dd>\n</dl>"}},{"type":"prose","value":{"id":"examples","title":"Examples","isH3":false,"content":""}},{"type":"prose","value":{"id":"creating_a_new_registry","title":"Creating a new registry","isH3":true,"content":"<p>You create the registry passing in the callback:</p>\n<div class=\"code-example\"><div class=\"example-header\"><span class=\"language-name\">js</span></div><pre class=\"brush: js notranslate\"><code>const registry = new FinalizationRegistry((heldValue) =&gt; {\n  // …\n});\n</code></pre></div>"}},{"type":"prose","value":{"id":"registering_objects_for_cleanup","title":"Registering objects for cleanup","isH3":true,"content":"<p>Then you register any objects you want a cleanup callback for by calling the <code>register</code> method, passing in the object and a <em>held value</em> for it:</p>\n<div class=\"code-example\"><div class=\"example-header\"><span class=\"language-name\">js</span></div><pre class=\"brush: js notranslate\"><code>registry.register(theObject, \"some value\");\n</code></pre></div>"}},{"type":"prose","value":{"id":"callbacks_never_called_synchronously","title":"Callbacks never called synchronously","isH3":true,"content":"<p>No matter how much pressure you put on the garbage collector, the cleanup callback will never be called synchronously. The object may be reclaimed synchronously, but the callback will always be called sometime after the current job finishes:</p>\n<div class=\"code-example\"><div class=\"example-header\"><span class=\"language-name\">js</span></div><pre class=\"brush: js notranslate\"><code>let counter = 0;\nconst registry = new FinalizationRegistry(() =&gt; {\n  console.log(`Array gets garbage collected at ${counter}`);\n});\n\nregistry.register([\"foo\"]);\n\n(function allocateMemory() {\n  // Allocate 50000 functions — a lot of memory!\n  Array.from({ length: 50000 }, () =&gt; () =&gt; {});\n  if (counter &gt; 5000) return;\n  counter++;\n  allocateMemory();\n})();\n\nconsole.log(\"Main job ends\");\n// Logs:\n// Main job ends\n// Array gets garbage collected at 5001\n</code></pre></div>\n<p>However, if you allow a little break between each allocation, the callback may be called sooner:</p>\n<div class=\"code-example\"><div class=\"example-header\"><span class=\"language-name\">js</span></div><pre class=\"brush: js notranslate\"><code>let arrayCollected = false;\nlet counter = 0;\nconst registry = new FinalizationRegistry(() =&gt; {\n  console.log(`Array gets garbage collected at ${counter}`);\n  arrayCollected = true;\n});\n\nregistry.register([\"foo\"]);\n\n(function allocateMemory() {\n  // Allocate 50000 functions — a lot of memory!\n  Array.from({ length: 50000 }, () =&gt; () =&gt; {});\n  if (counter &gt; 5000 || arrayCollected) return;\n  counter++;\n  // Use setTimeout to make each allocateMemory a different job\n  setTimeout(allocateMemory);\n})();\n\nconsole.log(\"Main job ends\");\n</code></pre></div>\n<p>There's no guarantee that the callback will be called sooner or if it will be called at all, but there's a possibility that the logged message has a counter value smaller than 5000.</p>"}},{"type":"specifications","value":{"id":"specifications","title":"Specifications","isH3":false,"specifications":[{"bcdSpecificationURL":"https://tc39.es/ecma262/multipage/managing-memory.html#sec-finalization-registry-objects","title":"ECMAScript Language Specification"}],"query":"javascript.builtins.FinalizationRegistry"}},{"type":"browser_compatibility","value":{"id":"browser_compatibility","title":"Browser compatibility","isH3":false,"query":"javascript.builtins.FinalizationRegistry"}},{"type":"prose","value":{"id":"see_also","title":"See also","isH3":false,"content":"<ul>\n<li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakRef\"><code>WeakRef</code></a></li>\n<li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakSet\"><code>WeakSet</code></a></li>\n<li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap\"><code>WeakMap</code></a></li>\n</ul>"}}],"isActive":true,"isMarkdown":true,"isTranslated":false,"locale":"en-US","mdn_url":"/en-US/docs/Web/JavaScript/Reference/Global_Objects/FinalizationRegistry","modified":"2024-07-25T21:32:46.000Z","native":"English (US)","noIndexing":false,"other_translations":[{"locale":"de","title":"FinalizationRegistry","native":"Deutsch"},{"locale":"fr","title":"FinalizationRegistry","native":"Français"},{"locale":"ja","title":"FinalizationRegistry","native":"日本語"}],"pageTitle":"FinalizationRegistry - JavaScript | MDN","parents":[{"uri":"/en-US/docs/Web","title":"References"},{"uri":"/en-US/docs/Web/JavaScript","title":"JavaScript"},{"uri":"/en-US/docs/Web/JavaScript/Reference","title":"Reference"},{"uri":"/en-US/docs/Web/JavaScript/Reference/Global_Objects","title":"Standard built-in objects"},{"uri":"/en-US/docs/Web/JavaScript/Reference/Global_Objects/FinalizationRegistry","title":"FinalizationRegistry"}],"popularity":null,"short_title":"FinalizationRegistry","sidebarHTML":"<ol><li class=\"section\"><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects\">Standard built-in objects</a></li><li class=\"section\"><em><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/FinalizationRegistry\" aria-current=\"page\"><code>FinalizationRegistry</code></a></em></li><li class=\"toggle\"><details open=\"\"><summary>Constructor</summary><ol><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/FinalizationRegistry/FinalizationRegistry\"><code>FinalizationRegistry() constructor</code></a></li></ol></details></li><li class=\"toggle\"><details open=\"\"><summary>Instance methods</summary><ol><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/FinalizationRegistry/register\"><code>FinalizationRegistry.prototype.register()</code></a></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/FinalizationRegistry/unregister\"><code>FinalizationRegistry.prototype.unregister()</code></a></li></ol></details></li><li class=\"section\">Inheritance</li><li class=\"section\"><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object\"><code>Object/Function</code></a></li><li class=\"toggle\"><details><summary>Static methods</summary><ol><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply\"><code>Function.prototype.apply()</code></a></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind\"><code>Function.prototype.bind()</code></a></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call\"><code>Function.prototype.call()</code></a></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/toString\"><code>Function.prototype.toString()</code></a></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/Symbol.hasInstance\"><code>Function.prototype[Symbol.hasInstance]()</code></a></li></ol></details></li><li class=\"toggle\"><details><summary>Static properties</summary><ol><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/displayName\"><code>Function: displayName</code></a><abbr class=\"icon icon-nonstandard\" title=\"Non-standard. Check cross-browser support before using.\">\n<span class=\"visually-hidden\">Non-standard</span>\n</abbr></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/length\"><code>Function: length</code></a></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name\"><code>Function: name</code></a></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/prototype\"><code>Function: prototype</code></a></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/arguments\"><code>Function.prototype.arguments</code></a><abbr class=\"icon icon-nonstandard\" title=\"Non-standard. Check cross-browser support before using.\">\n<span class=\"visually-hidden\">Non-standard</span>\n</abbr><abbr class=\"icon icon-deprecated\" title=\"Deprecated. Not for use in new websites.\">\n<span class=\"visually-hidden\">Deprecated</span>\n</abbr></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/caller\"><code>Function.prototype.caller</code></a><abbr class=\"icon icon-nonstandard\" title=\"Non-standard. Check cross-browser support before using.\">\n<span class=\"visually-hidden\">Non-standard</span>\n</abbr><abbr class=\"icon icon-deprecated\" title=\"Deprecated. Not for use in new websites.\">\n<span class=\"visually-hidden\">Deprecated</span>\n</abbr></li></ol></details></li><li class=\"toggle\"><details><summary>Instance methods</summary><ol><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/__defineGetter__\"><code>Object.prototype.__defineGetter__()</code></a><abbr class=\"icon icon-deprecated\" title=\"Deprecated. Not for use in new websites.\">\n<span class=\"visually-hidden\">Deprecated</span>\n</abbr></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/__defineSetter__\"><code>Object.prototype.__defineSetter__()</code></a><abbr class=\"icon icon-deprecated\" title=\"Deprecated. Not for use in new websites.\">\n<span class=\"visually-hidden\">Deprecated</span>\n</abbr></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/__lookupGetter__\"><code>Object.prototype.__lookupGetter__()</code></a><abbr class=\"icon icon-deprecated\" title=\"Deprecated. Not for use in new websites.\">\n<span class=\"visually-hidden\">Deprecated</span>\n</abbr></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/__lookupSetter__\"><code>Object.prototype.__lookupSetter__()</code></a><abbr class=\"icon icon-deprecated\" title=\"Deprecated. Not for use in new websites.\">\n<span class=\"visually-hidden\">Deprecated</span>\n</abbr></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty\"><code>Object.prototype.hasOwnProperty()</code></a></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isPrototypeOf\"><code>Object.prototype.isPrototypeOf()</code></a></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/propertyIsEnumerable\"><code>Object.prototype.propertyIsEnumerable()</code></a></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/toLocaleString\"><code>Object.prototype.toLocaleString()</code></a></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/toString\"><code>Object.prototype.toString()</code></a></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/valueOf\"><code>Object.prototype.valueOf()</code></a></li></ol></details></li><li class=\"toggle\"><details><summary>Instance properties</summary><ol><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/proto\"><code>Object.prototype.__proto__</code></a><abbr class=\"icon icon-deprecated\" title=\"Deprecated. Not for use in new websites.\">\n<span class=\"visually-hidden\">Deprecated</span>\n</abbr></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/constructor\"><code>Object.prototype.constructor</code></a></li></ol></details></li></ol>","source":{"folder":"en-us/web/javascript/reference/global_objects/finalizationregistry","github_url":"https://github.com/mdn/content/blob/main/files/en-us/web/javascript/reference/global_objects/finalizationregistry/index.md","last_commit_url":"https://github.com/mdn/content/commit/8421c0cd94fa5aa237c833ac6d24885edbc7d721","filename":"index.md"},"summary":"A FinalizationRegistry object lets you request a callback when a value is garbage-collected.","title":"FinalizationRegistry","toc":[{"text":"Description","id":"description"},{"text":"Constructor","id":"constructor"},{"text":"Instance properties","id":"instance_properties"},{"text":"Instance methods","id":"instance_methods"},{"text":"Examples","id":"examples"},{"text":"Specifications","id":"specifications"},{"text":"Browser compatibility","id":"browser_compatibility"},{"text":"See also","id":"see_also"}],"baseline":{"baseline":"high","baseline_low_date":"2021-04-26","baseline_high_date":"2023-10-26","support":{"chrome":"84","chrome_android":"84","edge":"84","firefox":"79","firefox_android":"79","safari":"14.1","safari_ios":"14.5"},"asterisk":true},"browserCompat":["javascript.builtins.FinalizationRegistry"],"pageType":"javascript-class"}}</script>

</body><!-- Mirrored from developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/FinalizationRegistry by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 08 Jan 2025 13:04:32 GMT --></html>