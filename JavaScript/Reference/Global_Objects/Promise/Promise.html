<!DOCTYPE html><html lang="en-US" prefix="og: https://ogp.me/ns#"><!-- Mirrored from developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/Promise by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 08 Jan 2025 13:10:17 GMT --><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="icon" href="https://developer.mozilla.org/favicon-48x48.bc390275e955dacb2e65.png"><link rel="apple-touch-icon" href="https://developer.mozilla.org/apple-touch-icon.528534bba673c38049c2.png"><meta name="theme-color" content="#ffffff"><link rel="manifest" href="https://developer.mozilla.org/manifest.f42880861b394dd4dc9b.json"><link rel="search" type="application/opensearchdescription+xml" href="https://developer.mozilla.org/opensearch.xml" title="MDN Web Docs"><title>Promise() constructor - JavaScript | MDN</title><link rel="alternate" title="Promise() Konstruktor" href="https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Promise/Promise" hreflang="de"><link rel="alternate" title="Constructeur Promise()" href="https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Global_Objects/Promise/Promise" hreflang="fr"><link rel="alternate" title="Promise() コンストラクター" href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Promise/Promise" hreflang="ja"><link rel="alternate" title="Promise() 생성자" href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Promise/Promise" hreflang="ko"><link rel="alternate" title="Promise() 构造函数" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/Promise" hreflang="zh"><link rel="alternate" title="Promise() constructor" href="Promise.html" hreflang="en"><link rel="preload" as="font" type="font/woff2" href="https://developer.mozilla.org/static/media/Inter.var.c2fe3cb2b7c746f7966a.woff2" crossorigin=""><link rel="alternate" type="application/rss+xml" title="MDN Blog RSS Feed" href="https://developer.mozilla.org/en-US/blog/rss.xml" hreflang="en"><meta name="description" content="The Promise() constructor creates Promise objects. It is primarily used to wrap callback-based APIs that do not already support promises."><meta property="og:url" content="Promise.html"><meta property="og:title" content="Promise() constructor - JavaScript | MDN"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:description" content="The Promise() constructor creates Promise objects. It is primarily used to wrap callback-based APIs that do not already support promises."><meta property="og:image" content="https://developer.mozilla.org/mdn-social-share.d893525a4fb5fb1f67a2.png"><meta property="og:image:type" content="image/png"><meta property="og:image:height" content="1080"><meta property="og:image:width" content="1920"><meta property="og:image:alt" content="The MDN Web Docs logo, featuring a blue accent color, displayed on a solid black background."><meta property="og:site_name" content="MDN Web Docs"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:creator" content="MozDevNet"><link rel="canonical" href="Promise.html"><style media="print">.article-actions-container,.document-toc-container,.language-menu,.main-menu-toggle,.on-github,.page-footer,.place,.sidebar,.top-banner,.top-navigation-main,ul.prev-next{display:none!important}.main-page-content,.main-page-content pre{padding:2px}.main-page-content pre{border-left-width:2px}</style><link href="https://developer.mozilla.org/static/css/main.65aa8eed.css" rel="stylesheet"></head><body><script>if(document.body.addEventListener("load",(t=>{t.target.classList.contains("interactive")&&t.target.setAttribute("data-readystate","complete")}),{capture:!0}),window&&document.documentElement){const t={light:"#ffffff",dark:"#1b1b1b"};try{const e=window.localStorage.getItem("theme");e&&(document.documentElement.className=e,document.documentElement.style.backgroundColor=t[e]);const o=window.localStorage.getItem("nop");o&&(document.documentElement.dataset.nop=o)}catch(t){console.warn("Unable to read theme from localStorage",t)}}</script><div id="root"><div class="page-wrapper  category-javascript document-page"><div class="main-wrapper"><main id="content" class="main-content  "><article class="main-page-content" lang="en-US"><header><h1>Promise() constructor</h1><details class="baseline-indicator high"><summary><span class="indicator" role="img" aria-label="Baseline Check"></span><h2>Baseline<!-- --> <span class="not-bold">Widely available</span></h2><div class="browsers"><span class="engine" title="Supported in Chrome and Edge"><span class="browser chrome supported" role="img" aria-label="Chrome check"></span><span class="browser edge supported" role="img" aria-label="Edge check"></span></span><span class="engine" title="Supported in Firefox"><span class="browser firefox supported" role="img" aria-label="Firefox check"></span></span><span class="engine" title="Supported in Safari"><span class="browser safari supported" role="img" aria-label="Safari check"></span></span></div><span class="icon icon-chevron "></span></summary><div class="extra"><p>This feature is well established and works across many devices and browser versions. It’s been available across browsers since<!-- --> <!-- -->July 2015<!-- -->.</p><ul><li><a href="https://developer.mozilla.org/en-US/docs/Glossary/Baseline/Compatibility" data-glean="baseline_link_learn_more" target="_blank" class="learn-more">Learn more</a></li><li><a href="#browser_compatibility" data-glean="baseline_link_bcd_table">See full compatibility</a></li><li><a href="https://survey.alchemer.com/s3/7634825/MDN-baseline-feedback?page=%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FPromise%2FPromise&amp;level=high" data-glean="baseline_link_feedback" class="feedback-link" target="_blank" rel="noreferrer">Report feedback</a></li></ul></div></details></header><div class="section-content"><p>The <strong><code>Promise()</code></strong> constructor creates <a href="../Promise.html"><code>Promise</code></a> objects. It is primarily used to wrap callback-based APIs that do not already support promises.</p></div><section aria-labelledby="try_it"><h2 id="try_it"><a href="#try_it">Try it</a></h2><div class="section-content"><iframe class="interactive is-taller-height" height="200" src="https://interactive-examples.mdn.mozilla.net/pages/js/promise-constructor.html" title="MDN Web Docs Interactive Example" allow="clipboard-write" loading="lazy"></iframe></div></section><section aria-labelledby="syntax"><h2 id="syntax"><a href="#syntax">Syntax</a></h2><div class="section-content"><div class="code-example"><div class="example-header"><span class="language-name">js</span></div><pre class="brush: js notranslate"><code>new Promise(executor)
</code></pre></div>
<div class="notecard note">
<p><strong>Note:</strong> <code>Promise()</code> can only be constructed with <a href="../../Operators/new.html"><code>new</code></a>. Attempting to call it without <code>new</code> throws a <a href="../TypeError.html"><code>TypeError</code></a>.</p>
</div></div></section><section aria-labelledby="parameters"><h3 id="parameters"><a href="#parameters">Parameters</a></h3><div class="section-content"><dl>
<dt id="executor"><a href="#executor"><code>executor</code></a></dt>
<dd>
<p>A <a href="../Function.html"><code>function</code></a> to be executed by the constructor. It receives two functions as parameters: <code>resolveFunc</code> and <code>rejectFunc</code>. Any errors thrown in the <code>executor</code> will cause the promise to be rejected, and the return value will be neglected. The semantics of <code>executor</code> are detailed below.</p>
</dd>
</dl></div></section><section aria-labelledby="return_value"><h3 id="return_value"><a href="#return_value">Return value</a></h3><div class="section-content"><p>When called via <code>new</code>, the <code>Promise</code> constructor returns a promise object. The promise object will become <em>resolved</em> when either of the functions <code>resolveFunc</code> or <code>rejectFunc</code> are invoked. Note that if you call <code>resolveFunc</code> and pass another promise object as an argument, the initial promise can be said to be "resolved", but still not "settled". See the <a href="../Promise.html#description">Promise description</a> for more explanation.</p></div></section><section aria-labelledby="description"><h2 id="description"><a href="#description">Description</a></h2><div class="section-content"><p>Traditionally (before promises), asynchronous tasks were designed as callbacks.</p>
<div class="code-example"><div class="example-header"><span class="language-name">js</span></div><pre class="brush: js notranslate"><code>readFile("./data.txt", (error, result) =&gt; {
  // This callback will be called when the task is done, with the
  // final `error` or `result`. Any operation dependent on the
  // result must be defined within this callback.
});
// Code here is immediately executed after the `readFile` request
// is fired. It does not wait for the callback to be called, hence
// making `readFile` "asynchronous".
</code></pre></div>
<p>To take advantage of the readability improvement and language features offered by promises, the <code>Promise()</code> constructor allows one to transform the callback-based API to a promise-based one.</p>
<div class="notecard note">
<p><strong>Note:</strong>
If your task is already promise-based, you likely do not need the <code>Promise()</code> constructor.</p>
</div>
<p>The <code>executor</code> is custom code that ties an outcome in a callback to a promise. You, the programmer, write the <code>executor</code>. Its signature is expected to be:</p>
<div class="code-example"><div class="example-header"><span class="language-name">js</span></div><pre class="brush: js notranslate"><code>function executor(resolveFunc, rejectFunc) {
  // Typically, some asynchronous operation that accepts a callback,
  // like the `readFile` function above
}
</code></pre></div>
<p><code>resolveFunc</code> and <code>rejectFunc</code> are also functions, and you can give them whatever actual names you want. Their signatures are simple: they accept a single parameter of any type.</p>
<div class="code-example"><div class="example-header"><span class="language-name">js</span></div><pre class="brush: js notranslate"><code>resolveFunc(value); // call on resolved
rejectFunc(reason); // call on rejected
</code></pre></div>
<p>The <code>value</code> parameter passed to <code>resolveFunc</code> can be another promise object, in which case the newly constructed promise's state will be "locked in" to the promise passed (as part of the <a href="#the_resolve_function">resolution</a> promise). The <code>rejectFunc</code> has semantics close to the <a href="../../Statements/throw.html"><code>throw</code></a> statement, so <code>reason</code> is typically an <a href="../Error.html"><code>Error</code></a> instance. If either <code>value</code> or <code>reason</code> is omitted, the promise is fulfilled/rejected with <code>undefined</code>.</p>
<p>The <code>executor</code>'s completion state has limited effect on the promise's state:</p>
<ul>
<li>The <code>executor</code> return value is ignored. <code>return</code> statements within the <code>executor</code> merely impact control flow and alter whether a part of the function is executed, but do not have any impact on the promise's fulfillment value. If <code>executor</code> exits and it's impossible for <code>resolveFunc</code> or <code>rejectFunc</code> to be called in the future (for example, there are no async tasks scheduled), then the promise remains pending forever.</li>
<li>If an error is thrown in the <code>executor</code>, the promise is rejected, unless <code>resolveFunc</code> or <code>rejectFunc</code> has already been called.</li>
</ul>
<div class="notecard note">
<p><strong>Note:</strong>
The existence of pending promises does not prevent the program from exiting. If the event loop is empty, the program exits despite any pending promises (because those are necessarily forever-pending).</p>
</div>
<p>Here's a summary of the typical flow:</p>
<ol>
<li>At the time when the constructor generates the new <code>Promise</code> object, it also generates a corresponding pair of functions for <code>resolveFunc</code> and <code>rejectFunc</code>; these are "tethered" to the <code>Promise</code> object.</li>
<li><code>executor</code> typically wraps some asynchronous operation which provides a callback-based API. The callback (the one passed to the original callback-based API) is defined within the <code>executor</code> code, so it has access to the <code>resolveFunc</code> and <code>rejectFunc</code>.</li>
<li>The <code>executor</code> is called synchronously (as soon as the <code>Promise</code> is constructed) with the <code>resolveFunc</code> and <code>rejectFunc</code> functions as arguments.</li>
<li>The code within the <code>executor</code> has the opportunity to perform some operation. The eventual completion of the asynchronous task is communicated with the promise instance via the side effect caused by <code>resolveFunc</code> or <code>rejectFunc</code>. The side effect is that the <code>Promise</code> object becomes "resolved".
<ul>
<li>If <code>resolveFunc</code> is called first, the value passed will be <a href="#the_resolve_function">resolved</a>. The promise may stay pending (in case another <a href="../Promise.html#thenables">thenable</a> is passed), become fulfilled (in most cases where a non-thenable value is passed), or become rejected (in case of an invalid resolution value).</li>
<li>If <code>rejectFunc</code> is called first, the promise instantly becomes rejected.</li>
<li>Once one of the resolving functions (<code>resolveFunc</code> or <code>rejectFunc</code>) is called, the promise stays resolved. Only the first call to <code>resolveFunc</code> or <code>rejectFunc</code> affects the promise's eventual state, and subsequent calls to either function can neither change the fulfillment value/rejection reason nor toggle its eventual state from "fulfilled" to "rejected" or opposite.</li>
<li>If <code>executor</code> exits by throwing an error, then the promise is rejected. However, the error is ignored if one of the resolving functions has already been called (so that the promise is already resolved).</li>
<li>Resolving the promise does not necessarily cause the promise to become fulfilled or rejected (i.e. settled). The promise may still be pending because it's resolved with another thenable, but its eventual state will match that of the resolved thenable.</li>
</ul>
</li>
<li>Once the promise settles, it (asynchronously) invokes any further handlers associated through <a href="then.html"><code>then()</code></a>, <a href="catch.html"><code>catch()</code></a>, or <a href="finally.html"><code>finally()</code></a>. The eventual fulfillment value or rejection reason is passed to the invocation of fulfillment and rejection handlers as an input parameter (see <a href="../Promise.html#chained_promises">Chained Promises</a>).</li>
</ol>
<p>For example, the callback-based <code>readFile</code> API above can be transformed into a promise-based one.</p>
<div class="code-example"><div class="example-header"><span class="language-name">js</span></div><pre class="brush: js notranslate"><code>const readFilePromise = (path) =&gt;
  new Promise((resolve, reject) =&gt; {
    readFile(path, (error, result) =&gt; {
      if (error) {
        reject(error);
      } else {
        resolve(result);
      }
    });
  });

readFilePromise("./data.txt")
  .then((result) =&gt; console.log(result))
  .catch((error) =&gt; console.error("Failed to read data"));
</code></pre></div>
<p>The <code>resolve</code> and <code>reject</code> callbacks are only available within the scope of the executor function, which means you can't access them after the promise is constructed. If you want to construct the promise before deciding how to resolve it, you can use the <a href="withResolvers.html"><code>Promise.withResolvers()</code></a> method instead, which exposes the <code>resolve</code> and <code>reject</code> functions.</p></div></section><section aria-labelledby="the_resolve_function"><h3 id="the_resolve_function"><a href="#the_resolve_function">The resolve function</a></h3><div class="section-content"><p>The <code>resolve</code> function has the following behaviors:</p>
<ul>
<li>If it's called with the same value as the newly created promise (the promise it's "tethered to"), the promise is rejected with a <a href="../TypeError.html"><code>TypeError</code></a>.</li>
<li>If it's called with a non-<a href="../Promise.html#thenables">thenable</a> value (a primitive, or an object whose <code>then</code> property is not callable, including when the property is not present), the promise is immediately fulfilled with that value.</li>
<li>If it's called with a thenable value (including another <code>Promise</code> instance), then the thenable's <code>then</code> method is saved and called in the future (it's always called asynchronously). The <code>then</code> method will be called with two callbacks, which are two new functions with the exact same behaviors as the <code>resolveFunc</code> and <code>rejectFunc</code> passed to the <code>executor</code> function. If calling the <code>then</code> method throws, then the current promise is rejected with the thrown error.</li>
</ul>
<p>In the last case, it means code like:</p>
<div class="code-example"><div class="example-header"><span class="language-name">js</span></div><pre class="brush: js notranslate"><code>new Promise((resolve, reject) =&gt; {
  resolve(thenable);
});
</code></pre></div>
<p>Is roughly equivalent to:</p>
<div class="code-example"><div class="example-header"><span class="language-name">js</span></div><pre class="brush: js notranslate"><code>new Promise((resolve, reject) =&gt; {
  try {
    thenable.then(
      (value) =&gt; resolve(value),
      (reason) =&gt; reject(reason),
    );
  } catch (e) {
    reject(e);
  }
});
</code></pre></div>
<p>Except that in the <code>resolve(thenable)</code> case:</p>
<ol>
<li><code>resolve</code> is called synchronously, so that calling <code>resolve</code> or <code>reject</code> again has no effect, even when the handlers attached through <code>anotherPromise.then()</code> are not called yet.</li>
<li>The <code>then</code> method is called asynchronously, so that the promise will never be instantly resolved if a thenable is passed.</li>
</ol>
<p>Because <code>resolve</code> is called again with whatever <code>thenable.then()</code> passes to it as <code>value</code>, the resolver function is able to flatten nested thenables, where a thenable calls its <code>onFulfilled</code> handler with another thenable. The effect is that the fulfillment handler of a real promise will never receive a thenable as its fulfillment value.</p></div></section><section aria-labelledby="examples"><h2 id="examples"><a href="#examples">Examples</a></h2><div class="section-content"></div></section><section aria-labelledby="turning_a_callback-based_api_into_a_promise-based_one"><h3 id="turning_a_callback-based_api_into_a_promise-based_one"><a href="#turning_a_callback-based_api_into_a_promise-based_one">Turning a callback-based API into a promise-based one</a></h3><div class="section-content"><p>To provide a function with promise functionality, have it return a promise by calling the <code>resolve</code> and <code>reject</code> functions at the correct times.</p>
<div class="code-example"><div class="example-header"><span class="language-name">js</span></div><pre class="brush: js notranslate"><code>function myAsyncFunction(url) {
  return new Promise((resolve, reject) =&gt; {
    const xhr = new XMLHttpRequest();
    xhr.open("GET", url);
    xhr.onload = () =&gt; resolve(xhr.responseText);
    xhr.onerror = () =&gt; reject(xhr.statusText);
    xhr.send();
  });
}
</code></pre></div></div></section><section aria-labelledby="effect_of_calling_resolvefunc"><h3 id="effect_of_calling_resolvefunc"><a href="#effect_of_calling_resolvefunc">Effect of calling resolveFunc</a></h3><div class="section-content"><p>Calling <code>resolveFunc</code> causes the promise to become resolved, so that calling <code>resolveFunc</code> or <code>rejectFunc</code> again has no effect. However, the promise may be in any of the states: pending, fulfilled, or rejected.</p>
<p>This <code>pendingResolved</code> promise is resolved the time it's created, because it has already been "locked in" to match the eventual state of the inner promise, and calling <code>resolveOuter</code> or <code>rejectOuter</code> or throwing an error later in the executor has no effect on its eventual state. However, the inner promise is still pending until 100ms later, so the outer promise is also pending:</p>
<div class="code-example"><div class="example-header"><span class="language-name">js</span></div><pre class="brush: js notranslate"><code>const pendingResolved = new Promise((resolveOuter, rejectOuter) =&gt; {
  resolveOuter(
    new Promise((resolveInner) =&gt; {
      setTimeout(() =&gt; {
        resolveInner("inner");
      }, 100);
    }),
  );
});
</code></pre></div>
<p>This <code>fulfilledResolved</code> promise becomes fulfilled the moment it's resolved, because it's resolved with a non-thenable value. However, when it's created, it's unresolved, because neither <code>resolve</code> nor <code>reject</code> has been called yet. An unresolved promise is necessarily pending:</p>
<div class="code-example"><div class="example-header"><span class="language-name">js</span></div><pre class="brush: js notranslate"><code>const fulfilledResolved = new Promise((resolve, reject) =&gt; {
  setTimeout(() =&gt; {
    resolve("outer");
  }, 100);
});
</code></pre></div>
<p>Calling <code>rejectFunc</code> obviously causes the promise to reject. However, there are also two ways to cause the promise to instantly become rejected even when the <code>resolveFunc</code> callback is called.</p>
<div class="code-example"><div class="example-header"><span class="language-name">js</span></div><pre class="brush: js notranslate"><code>// 1. Resolving with the promise itself
const rejectedResolved1 = new Promise((resolve) =&gt; {
  // Note: resolve has to be called asynchronously,
  // so that the rejectedResolved1 variable is initialized
  setTimeout(() =&gt; resolve(rejectedResolved1)); // TypeError: Chaining cycle detected for promise #&lt;Promise&gt;
});

// 2. Resolving with an object which throws when accessing the `then` property
const rejectedResolved2 = new Promise((resolve) =&gt; {
  resolve({
    get then() {
      throw new Error("Can't get then property");
    },
  });
});
</code></pre></div></div></section><h2 id="specifications"><a href="#specifications">Specifications</a></h2><table class="standard-table"><thead><tr><th scope="col">Specification</th></tr></thead><tbody><tr><td><a href="https://tc39.es/ecma262/multipage/control-abstraction-objects.html#sec-promise-constructor">ECMAScript Language Specification<!-- --> <br><small># <!-- -->sec-promise-constructor</small></a></td></tr></tbody></table><h2 id="browser_compatibility"><a href="#browser_compatibility">Browser compatibility</a></h2><p>BCD tables only load in the browser<noscript> <!-- -->with JavaScript enabled. Enable JavaScript to view data.</noscript></p><section aria-labelledby="see_also"><h2 id="see_also"><a href="#see_also">See also</a></h2><div class="section-content"><ul>
<li><a href="https://github.com/zloirock/core-js#ecmascript-promise" class="external" target="_blank">Polyfill of <code>Promise</code> in <code>core-js</code></a></li>
<li><a href="../../../Guide/Using_promises.html">Using promises</a> guide</li>
<li><a href="withResolvers.html"><code>Promise.withResolvers()</code></a></li>
</ul></div></section></article></main></div></div></div><script type="application/json" id="hydration">{"url":"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/Promise","doc":{"body":[{"type":"prose","value":{"id":null,"title":null,"isH3":false,"content":"<p>The <strong><code>Promise()</code></strong> constructor creates <a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise\"><code>Promise</code></a> objects. It is primarily used to wrap callback-based APIs that do not already support promises.</p>"}},{"type":"prose","value":{"id":"try_it","title":"Try it","isH3":false,"content":"<iframe class=\"interactive is-taller-height\" height=\"200\" src=\"https://interactive-examples.mdn.mozilla.net/pages/js/promise-constructor.html\" title=\"MDN Web Docs Interactive Example\" allow=\"clipboard-write\" loading=\"lazy\"></iframe>"}},{"type":"prose","value":{"id":"syntax","title":"Syntax","isH3":false,"content":"<div class=\"code-example\"><div class=\"example-header\"><span class=\"language-name\">js</span></div><pre class=\"brush: js notranslate\"><code>new Promise(executor)\n</code></pre></div>\n<div class=\"notecard note\">\n<p><strong>Note:</strong> <code>Promise()</code> can only be constructed with <a href=\"/en-US/docs/Web/JavaScript/Reference/Operators/new\"><code>new</code></a>. Attempting to call it without <code>new</code> throws a <a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError\"><code>TypeError</code></a>.</p>\n</div>"}},{"type":"prose","value":{"id":"parameters","title":"Parameters","isH3":true,"content":"<dl>\n<dt id=\"executor\"><a href=\"#executor\"><code>executor</code></a></dt>\n<dd>\n<p>A <a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function\"><code>function</code></a> to be executed by the constructor. It receives two functions as parameters: <code>resolveFunc</code> and <code>rejectFunc</code>. Any errors thrown in the <code>executor</code> will cause the promise to be rejected, and the return value will be neglected. The semantics of <code>executor</code> are detailed below.</p>\n</dd>\n</dl>"}},{"type":"prose","value":{"id":"return_value","title":"Return value","isH3":true,"content":"<p>When called via <code>new</code>, the <code>Promise</code> constructor returns a promise object. The promise object will become <em>resolved</em> when either of the functions <code>resolveFunc</code> or <code>rejectFunc</code> are invoked. Note that if you call <code>resolveFunc</code> and pass another promise object as an argument, the initial promise can be said to be \"resolved\", but still not \"settled\". See the <a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise#description\">Promise description</a> for more explanation.</p>"}},{"type":"prose","value":{"id":"description","title":"Description","isH3":false,"content":"<p>Traditionally (before promises), asynchronous tasks were designed as callbacks.</p>\n<div class=\"code-example\"><div class=\"example-header\"><span class=\"language-name\">js</span></div><pre class=\"brush: js notranslate\"><code>readFile(\"./data.txt\", (error, result) =&gt; {\n  // This callback will be called when the task is done, with the\n  // final `error` or `result`. Any operation dependent on the\n  // result must be defined within this callback.\n});\n// Code here is immediately executed after the `readFile` request\n// is fired. It does not wait for the callback to be called, hence\n// making `readFile` \"asynchronous\".\n</code></pre></div>\n<p>To take advantage of the readability improvement and language features offered by promises, the <code>Promise()</code> constructor allows one to transform the callback-based API to a promise-based one.</p>\n<div class=\"notecard note\">\n<p><strong>Note:</strong>\nIf your task is already promise-based, you likely do not need the <code>Promise()</code> constructor.</p>\n</div>\n<p>The <code>executor</code> is custom code that ties an outcome in a callback to a promise. You, the programmer, write the <code>executor</code>. Its signature is expected to be:</p>\n<div class=\"code-example\"><div class=\"example-header\"><span class=\"language-name\">js</span></div><pre class=\"brush: js notranslate\"><code>function executor(resolveFunc, rejectFunc) {\n  // Typically, some asynchronous operation that accepts a callback,\n  // like the `readFile` function above\n}\n</code></pre></div>\n<p><code>resolveFunc</code> and <code>rejectFunc</code> are also functions, and you can give them whatever actual names you want. Their signatures are simple: they accept a single parameter of any type.</p>\n<div class=\"code-example\"><div class=\"example-header\"><span class=\"language-name\">js</span></div><pre class=\"brush: js notranslate\"><code>resolveFunc(value); // call on resolved\nrejectFunc(reason); // call on rejected\n</code></pre></div>\n<p>The <code>value</code> parameter passed to <code>resolveFunc</code> can be another promise object, in which case the newly constructed promise's state will be \"locked in\" to the promise passed (as part of the <a href=\"#the_resolve_function\">resolution</a> promise). The <code>rejectFunc</code> has semantics close to the <a href=\"/en-US/docs/Web/JavaScript/Reference/Statements/throw\"><code>throw</code></a> statement, so <code>reason</code> is typically an <a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error\"><code>Error</code></a> instance. If either <code>value</code> or <code>reason</code> is omitted, the promise is fulfilled/rejected with <code>undefined</code>.</p>\n<p>The <code>executor</code>'s completion state has limited effect on the promise's state:</p>\n<ul>\n<li>The <code>executor</code> return value is ignored. <code>return</code> statements within the <code>executor</code> merely impact control flow and alter whether a part of the function is executed, but do not have any impact on the promise's fulfillment value. If <code>executor</code> exits and it's impossible for <code>resolveFunc</code> or <code>rejectFunc</code> to be called in the future (for example, there are no async tasks scheduled), then the promise remains pending forever.</li>\n<li>If an error is thrown in the <code>executor</code>, the promise is rejected, unless <code>resolveFunc</code> or <code>rejectFunc</code> has already been called.</li>\n</ul>\n<div class=\"notecard note\">\n<p><strong>Note:</strong>\nThe existence of pending promises does not prevent the program from exiting. If the event loop is empty, the program exits despite any pending promises (because those are necessarily forever-pending).</p>\n</div>\n<p>Here's a summary of the typical flow:</p>\n<ol>\n<li>At the time when the constructor generates the new <code>Promise</code> object, it also generates a corresponding pair of functions for <code>resolveFunc</code> and <code>rejectFunc</code>; these are \"tethered\" to the <code>Promise</code> object.</li>\n<li><code>executor</code> typically wraps some asynchronous operation which provides a callback-based API. The callback (the one passed to the original callback-based API) is defined within the <code>executor</code> code, so it has access to the <code>resolveFunc</code> and <code>rejectFunc</code>.</li>\n<li>The <code>executor</code> is called synchronously (as soon as the <code>Promise</code> is constructed) with the <code>resolveFunc</code> and <code>rejectFunc</code> functions as arguments.</li>\n<li>The code within the <code>executor</code> has the opportunity to perform some operation. The eventual completion of the asynchronous task is communicated with the promise instance via the side effect caused by <code>resolveFunc</code> or <code>rejectFunc</code>. The side effect is that the <code>Promise</code> object becomes \"resolved\".\n<ul>\n<li>If <code>resolveFunc</code> is called first, the value passed will be <a href=\"#the_resolve_function\">resolved</a>. The promise may stay pending (in case another <a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise#thenables\">thenable</a> is passed), become fulfilled (in most cases where a non-thenable value is passed), or become rejected (in case of an invalid resolution value).</li>\n<li>If <code>rejectFunc</code> is called first, the promise instantly becomes rejected.</li>\n<li>Once one of the resolving functions (<code>resolveFunc</code> or <code>rejectFunc</code>) is called, the promise stays resolved. Only the first call to <code>resolveFunc</code> or <code>rejectFunc</code> affects the promise's eventual state, and subsequent calls to either function can neither change the fulfillment value/rejection reason nor toggle its eventual state from \"fulfilled\" to \"rejected\" or opposite.</li>\n<li>If <code>executor</code> exits by throwing an error, then the promise is rejected. However, the error is ignored if one of the resolving functions has already been called (so that the promise is already resolved).</li>\n<li>Resolving the promise does not necessarily cause the promise to become fulfilled or rejected (i.e. settled). The promise may still be pending because it's resolved with another thenable, but its eventual state will match that of the resolved thenable.</li>\n</ul>\n</li>\n<li>Once the promise settles, it (asynchronously) invokes any further handlers associated through <a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then\"><code>then()</code></a>, <a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/catch\"><code>catch()</code></a>, or <a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/finally\"><code>finally()</code></a>. The eventual fulfillment value or rejection reason is passed to the invocation of fulfillment and rejection handlers as an input parameter (see <a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise#chained_promises\">Chained Promises</a>).</li>\n</ol>\n<p>For example, the callback-based <code>readFile</code> API above can be transformed into a promise-based one.</p>\n<div class=\"code-example\"><div class=\"example-header\"><span class=\"language-name\">js</span></div><pre class=\"brush: js notranslate\"><code>const readFilePromise = (path) =&gt;\n  new Promise((resolve, reject) =&gt; {\n    readFile(path, (error, result) =&gt; {\n      if (error) {\n        reject(error);\n      } else {\n        resolve(result);\n      }\n    });\n  });\n\nreadFilePromise(\"./data.txt\")\n  .then((result) =&gt; console.log(result))\n  .catch((error) =&gt; console.error(\"Failed to read data\"));\n</code></pre></div>\n<p>The <code>resolve</code> and <code>reject</code> callbacks are only available within the scope of the executor function, which means you can't access them after the promise is constructed. If you want to construct the promise before deciding how to resolve it, you can use the <a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/withResolvers\"><code>Promise.withResolvers()</code></a> method instead, which exposes the <code>resolve</code> and <code>reject</code> functions.</p>"}},{"type":"prose","value":{"id":"the_resolve_function","title":"The resolve function","isH3":true,"content":"<p>The <code>resolve</code> function has the following behaviors:</p>\n<ul>\n<li>If it's called with the same value as the newly created promise (the promise it's \"tethered to\"), the promise is rejected with a <a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError\"><code>TypeError</code></a>.</li>\n<li>If it's called with a non-<a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise#thenables\">thenable</a> value (a primitive, or an object whose <code>then</code> property is not callable, including when the property is not present), the promise is immediately fulfilled with that value.</li>\n<li>If it's called with a thenable value (including another <code>Promise</code> instance), then the thenable's <code>then</code> method is saved and called in the future (it's always called asynchronously). The <code>then</code> method will be called with two callbacks, which are two new functions with the exact same behaviors as the <code>resolveFunc</code> and <code>rejectFunc</code> passed to the <code>executor</code> function. If calling the <code>then</code> method throws, then the current promise is rejected with the thrown error.</li>\n</ul>\n<p>In the last case, it means code like:</p>\n<div class=\"code-example\"><div class=\"example-header\"><span class=\"language-name\">js</span></div><pre class=\"brush: js notranslate\"><code>new Promise((resolve, reject) =&gt; {\n  resolve(thenable);\n});\n</code></pre></div>\n<p>Is roughly equivalent to:</p>\n<div class=\"code-example\"><div class=\"example-header\"><span class=\"language-name\">js</span></div><pre class=\"brush: js notranslate\"><code>new Promise((resolve, reject) =&gt; {\n  try {\n    thenable.then(\n      (value) =&gt; resolve(value),\n      (reason) =&gt; reject(reason),\n    );\n  } catch (e) {\n    reject(e);\n  }\n});\n</code></pre></div>\n<p>Except that in the <code>resolve(thenable)</code> case:</p>\n<ol>\n<li><code>resolve</code> is called synchronously, so that calling <code>resolve</code> or <code>reject</code> again has no effect, even when the handlers attached through <code>anotherPromise.then()</code> are not called yet.</li>\n<li>The <code>then</code> method is called asynchronously, so that the promise will never be instantly resolved if a thenable is passed.</li>\n</ol>\n<p>Because <code>resolve</code> is called again with whatever <code>thenable.then()</code> passes to it as <code>value</code>, the resolver function is able to flatten nested thenables, where a thenable calls its <code>onFulfilled</code> handler with another thenable. The effect is that the fulfillment handler of a real promise will never receive a thenable as its fulfillment value.</p>"}},{"type":"prose","value":{"id":"examples","title":"Examples","isH3":false,"content":""}},{"type":"prose","value":{"id":"turning_a_callback-based_api_into_a_promise-based_one","title":"Turning a callback-based API into a promise-based one","isH3":true,"content":"<p>To provide a function with promise functionality, have it return a promise by calling the <code>resolve</code> and <code>reject</code> functions at the correct times.</p>\n<div class=\"code-example\"><div class=\"example-header\"><span class=\"language-name\">js</span></div><pre class=\"brush: js notranslate\"><code>function myAsyncFunction(url) {\n  return new Promise((resolve, reject) =&gt; {\n    const xhr = new XMLHttpRequest();\n    xhr.open(\"GET\", url);\n    xhr.onload = () =&gt; resolve(xhr.responseText);\n    xhr.onerror = () =&gt; reject(xhr.statusText);\n    xhr.send();\n  });\n}\n</code></pre></div>"}},{"type":"prose","value":{"id":"effect_of_calling_resolvefunc","title":"Effect of calling resolveFunc","isH3":true,"content":"<p>Calling <code>resolveFunc</code> causes the promise to become resolved, so that calling <code>resolveFunc</code> or <code>rejectFunc</code> again has no effect. However, the promise may be in any of the states: pending, fulfilled, or rejected.</p>\n<p>This <code>pendingResolved</code> promise is resolved the time it's created, because it has already been \"locked in\" to match the eventual state of the inner promise, and calling <code>resolveOuter</code> or <code>rejectOuter</code> or throwing an error later in the executor has no effect on its eventual state. However, the inner promise is still pending until 100ms later, so the outer promise is also pending:</p>\n<div class=\"code-example\"><div class=\"example-header\"><span class=\"language-name\">js</span></div><pre class=\"brush: js notranslate\"><code>const pendingResolved = new Promise((resolveOuter, rejectOuter) =&gt; {\n  resolveOuter(\n    new Promise((resolveInner) =&gt; {\n      setTimeout(() =&gt; {\n        resolveInner(\"inner\");\n      }, 100);\n    }),\n  );\n});\n</code></pre></div>\n<p>This <code>fulfilledResolved</code> promise becomes fulfilled the moment it's resolved, because it's resolved with a non-thenable value. However, when it's created, it's unresolved, because neither <code>resolve</code> nor <code>reject</code> has been called yet. An unresolved promise is necessarily pending:</p>\n<div class=\"code-example\"><div class=\"example-header\"><span class=\"language-name\">js</span></div><pre class=\"brush: js notranslate\"><code>const fulfilledResolved = new Promise((resolve, reject) =&gt; {\n  setTimeout(() =&gt; {\n    resolve(\"outer\");\n  }, 100);\n});\n</code></pre></div>\n<p>Calling <code>rejectFunc</code> obviously causes the promise to reject. However, there are also two ways to cause the promise to instantly become rejected even when the <code>resolveFunc</code> callback is called.</p>\n<div class=\"code-example\"><div class=\"example-header\"><span class=\"language-name\">js</span></div><pre class=\"brush: js notranslate\"><code>// 1. Resolving with the promise itself\nconst rejectedResolved1 = new Promise((resolve) =&gt; {\n  // Note: resolve has to be called asynchronously,\n  // so that the rejectedResolved1 variable is initialized\n  setTimeout(() =&gt; resolve(rejectedResolved1)); // TypeError: Chaining cycle detected for promise #&lt;Promise&gt;\n});\n\n// 2. Resolving with an object which throws when accessing the `then` property\nconst rejectedResolved2 = new Promise((resolve) =&gt; {\n  resolve({\n    get then() {\n      throw new Error(\"Can't get then property\");\n    },\n  });\n});\n</code></pre></div>"}},{"type":"specifications","value":{"id":"specifications","title":"Specifications","isH3":false,"specifications":[{"bcdSpecificationURL":"https://tc39.es/ecma262/multipage/control-abstraction-objects.html#sec-promise-constructor","title":"ECMAScript Language Specification"}],"query":"javascript.builtins.Promise.Promise"}},{"type":"browser_compatibility","value":{"id":"browser_compatibility","title":"Browser compatibility","isH3":false,"query":"javascript.builtins.Promise.Promise"}},{"type":"prose","value":{"id":"see_also","title":"See also","isH3":false,"content":"<ul>\n<li><a href=\"https://github.com/zloirock/core-js#ecmascript-promise\" class=\"external\" target=\"_blank\">Polyfill of <code>Promise</code> in <code>core-js</code></a></li>\n<li><a href=\"/en-US/docs/Web/JavaScript/Guide/Using_promises\">Using promises</a> guide</li>\n<li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/withResolvers\"><code>Promise.withResolvers()</code></a></li>\n</ul>"}}],"isActive":true,"isMarkdown":true,"isTranslated":false,"locale":"en-US","mdn_url":"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/Promise","modified":"2024-10-04T19:04:06.000Z","native":"English (US)","noIndexing":false,"other_translations":[{"locale":"de","title":"Promise() Konstruktor","native":"Deutsch"},{"locale":"fr","title":"Constructeur Promise()","native":"Français"},{"locale":"ja","title":"Promise() コンストラクター","native":"日本語"},{"locale":"ko","title":"Promise() 생성자","native":"한국어"},{"locale":"zh-CN","title":"Promise() 构造函数","native":"中文 (简体)"}],"pageTitle":"Promise() constructor - JavaScript | MDN","parents":[{"uri":"/en-US/docs/Web","title":"References"},{"uri":"/en-US/docs/Web/JavaScript","title":"JavaScript"},{"uri":"/en-US/docs/Web/JavaScript/Reference","title":"Reference"},{"uri":"/en-US/docs/Web/JavaScript/Reference/Global_Objects","title":"Standard built-in objects"},{"uri":"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise","title":"Promise"},{"uri":"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/Promise","title":"Promise() constructor"}],"popularity":null,"short_title":"Promise() constructor","sidebarHTML":"<ol><li class=\"section\"><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects\">Standard built-in objects</a></li><li class=\"section\"><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise\"><code>Promise</code></a></li><li class=\"toggle\"><details open=\"\"><summary>Constructor</summary><ol><li><em><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/Promise\" aria-current=\"page\"><code>Promise() constructor</code></a></em></li></ol></details></li><li class=\"toggle\"><details open=\"\"><summary>Static methods</summary><ol><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all\"><code>Promise.all()</code></a></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/allSettled\"><code>Promise.allSettled()</code></a></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/any\"><code>Promise.any()</code></a></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/race\"><code>Promise.race()</code></a></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/reject\"><code>Promise.reject()</code></a></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/resolve\"><code>Promise.resolve()</code></a></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/try\"><code>Promise.try()</code></a></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/withResolvers\"><code>Promise.withResolvers()</code></a></li></ol></details></li><li class=\"toggle\"><details open=\"\"><summary>Static properties</summary><ol><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/Symbol.species\"><code>Promise[Symbol.species]</code></a></li></ol></details></li><li class=\"toggle\"><details open=\"\"><summary>Instance methods</summary><ol><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/catch\"><code>Promise.prototype.catch()</code></a></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/finally\"><code>Promise.prototype.finally()</code></a></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then\"><code>Promise.prototype.then()</code></a></li></ol></details></li><li class=\"section\">Inheritance</li><li class=\"section\"><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object\"><code>Object/Function</code></a></li><li class=\"toggle\"><details><summary>Static methods</summary><ol><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply\"><code>Function.prototype.apply()</code></a></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind\"><code>Function.prototype.bind()</code></a></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call\"><code>Function.prototype.call()</code></a></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/toString\"><code>Function.prototype.toString()</code></a></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/Symbol.hasInstance\"><code>Function.prototype[Symbol.hasInstance]()</code></a></li></ol></details></li><li class=\"toggle\"><details><summary>Static properties</summary><ol><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/displayName\"><code>Function: displayName</code></a><abbr class=\"icon icon-nonstandard\" title=\"Non-standard. Check cross-browser support before using.\">\n<span class=\"visually-hidden\">Non-standard</span>\n</abbr></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/length\"><code>Function: length</code></a></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name\"><code>Function: name</code></a></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/prototype\"><code>Function: prototype</code></a></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/arguments\"><code>Function.prototype.arguments</code></a><abbr class=\"icon icon-nonstandard\" title=\"Non-standard. Check cross-browser support before using.\">\n<span class=\"visually-hidden\">Non-standard</span>\n</abbr><abbr class=\"icon icon-deprecated\" title=\"Deprecated. Not for use in new websites.\">\n<span class=\"visually-hidden\">Deprecated</span>\n</abbr></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/caller\"><code>Function.prototype.caller</code></a><abbr class=\"icon icon-nonstandard\" title=\"Non-standard. Check cross-browser support before using.\">\n<span class=\"visually-hidden\">Non-standard</span>\n</abbr><abbr class=\"icon icon-deprecated\" title=\"Deprecated. Not for use in new websites.\">\n<span class=\"visually-hidden\">Deprecated</span>\n</abbr></li></ol></details></li><li class=\"toggle\"><details><summary>Instance methods</summary><ol><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/__defineGetter__\"><code>Object.prototype.__defineGetter__()</code></a><abbr class=\"icon icon-deprecated\" title=\"Deprecated. Not for use in new websites.\">\n<span class=\"visually-hidden\">Deprecated</span>\n</abbr></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/__defineSetter__\"><code>Object.prototype.__defineSetter__()</code></a><abbr class=\"icon icon-deprecated\" title=\"Deprecated. Not for use in new websites.\">\n<span class=\"visually-hidden\">Deprecated</span>\n</abbr></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/__lookupGetter__\"><code>Object.prototype.__lookupGetter__()</code></a><abbr class=\"icon icon-deprecated\" title=\"Deprecated. Not for use in new websites.\">\n<span class=\"visually-hidden\">Deprecated</span>\n</abbr></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/__lookupSetter__\"><code>Object.prototype.__lookupSetter__()</code></a><abbr class=\"icon icon-deprecated\" title=\"Deprecated. Not for use in new websites.\">\n<span class=\"visually-hidden\">Deprecated</span>\n</abbr></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty\"><code>Object.prototype.hasOwnProperty()</code></a></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isPrototypeOf\"><code>Object.prototype.isPrototypeOf()</code></a></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/propertyIsEnumerable\"><code>Object.prototype.propertyIsEnumerable()</code></a></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/toLocaleString\"><code>Object.prototype.toLocaleString()</code></a></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/toString\"><code>Object.prototype.toString()</code></a></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/valueOf\"><code>Object.prototype.valueOf()</code></a></li></ol></details></li><li class=\"toggle\"><details><summary>Instance properties</summary><ol><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/proto\"><code>Object.prototype.__proto__</code></a><abbr class=\"icon icon-deprecated\" title=\"Deprecated. Not for use in new websites.\">\n<span class=\"visually-hidden\">Deprecated</span>\n</abbr></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/constructor\"><code>Object.prototype.constructor</code></a></li></ol></details></li></ol>","source":{"folder":"en-us/web/javascript/reference/global_objects/promise/promise","github_url":"https://github.com/mdn/content/blob/main/files/en-us/web/javascript/reference/global_objects/promise/promise/index.md","last_commit_url":"https://github.com/mdn/content/commit/1edfd3d5da5e1a559adb5d3a6a56beaed14845d6","filename":"index.md"},"summary":"The Promise() constructor creates Promise objects. It is primarily used to wrap callback-based APIs that do not already support promises.","title":"Promise() constructor","toc":[{"text":"Try it","id":"try_it"},{"text":"Syntax","id":"syntax"},{"text":"Description","id":"description"},{"text":"Examples","id":"examples"},{"text":"Specifications","id":"specifications"},{"text":"Browser compatibility","id":"browser_compatibility"},{"text":"See also","id":"see_also"}],"baseline":{"baseline":"high","baseline_low_date":"2015-07-29","baseline_high_date":"2018-01-29","support":{"chrome":"32","chrome_android":"32","edge":"12","firefox":"29","firefox_android":"29","safari":"8","safari_ios":"8"}},"browserCompat":["javascript.builtins.Promise.Promise"],"pageType":"javascript-constructor"}}</script>

</body><!-- Mirrored from developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/Promise by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 08 Jan 2025 13:10:17 GMT --></html>