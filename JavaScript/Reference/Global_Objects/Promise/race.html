<!DOCTYPE html><html lang="en-US" prefix="og: https://ogp.me/ns#"><!-- Mirrored from developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/race by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 08 Jan 2025 13:10:16 GMT --><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="icon" href="https://developer.mozilla.org/favicon-48x48.bc390275e955dacb2e65.png"><link rel="apple-touch-icon" href="https://developer.mozilla.org/apple-touch-icon.528534bba673c38049c2.png"><meta name="theme-color" content="#ffffff"><link rel="manifest" href="https://developer.mozilla.org/manifest.f42880861b394dd4dc9b.json"><link rel="search" type="application/opensearchdescription+xml" href="https://developer.mozilla.org/opensearch.xml" title="MDN Web Docs"><title>Promise.race()</title><link rel="alternate" title="Promise.race()" href="https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Promise/race" hreflang="de"><link rel="alternate" title="Promise.race()" href="https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Promise/race" hreflang="es"><link rel="alternate" title="Promise.race()" href="https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Global_Objects/Promise/race" hreflang="fr"><link rel="alternate" title="Promise.race()" href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Promise/race" hreflang="ja"><link rel="alternate" title="Promise.race()" href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Promise/race" hreflang="ko"><link rel="alternate" title="Promise.race()" href="https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Reference/Global_Objects/Promise/race" hreflang="pt"><link rel="alternate" title="Promise.race()" href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Promise/race" hreflang="ru"><link rel="alternate" title="Promise.race()" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/race" hreflang="zh"><link rel="alternate" title="Promise.race()" href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Promise/race" hreflang="zh-Hant"><link rel="alternate" title="Promise.race()" href="race.html" hreflang="en"><link rel="preload" as="font" type="font/woff2" href="https://developer.mozilla.org/static/media/Inter.var.c2fe3cb2b7c746f7966a.woff2" crossorigin=""><link rel="alternate" type="application/rss+xml" title="MDN Blog RSS Feed" href="https://developer.mozilla.org/en-US/blog/rss.xml" hreflang="en"><meta name="description" content="The Promise.race() static method takes an iterable of promises as input and returns a single Promise. This returned promise settles with the eventual state of the first promise that settles."><meta property="og:url" content="race.html"><meta property="og:title" content="Promise.race() - JavaScript | MDN"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:description" content="The Promise.race() static method takes an iterable of promises as input and returns a single Promise. This returned promise settles with the eventual state of the first promise that settles."><meta property="og:image" content="https://developer.mozilla.org/mdn-social-share.d893525a4fb5fb1f67a2.png"><meta property="og:image:type" content="image/png"><meta property="og:image:height" content="1080"><meta property="og:image:width" content="1920"><meta property="og:image:alt" content="The MDN Web Docs logo, featuring a blue accent color, displayed on a solid black background."><meta property="og:site_name" content="MDN Web Docs"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:creator" content="MozDevNet"><link rel="canonical" href="race.html"><style media="print">.article-actions-container,.document-toc-container,.language-menu,.main-menu-toggle,.on-github,.page-footer,.place,.sidebar,.top-banner,.top-navigation-main,ul.prev-next{display:none!important}.main-page-content,.main-page-content pre{padding:2px}.main-page-content pre{border-left-width:2px}</style><link href="https://developer.mozilla.org/static/css/main.65aa8eed.css" rel="stylesheet"></head><body><script>if(document.body.addEventListener("load",(t=>{t.target.classList.contains("interactive")&&t.target.setAttribute("data-readystate","complete")}),{capture:!0}),window&&document.documentElement){const t={light:"#ffffff",dark:"#1b1b1b"};try{const e=window.localStorage.getItem("theme");e&&(document.documentElement.className=e,document.documentElement.style.backgroundColor=t[e]);const o=window.localStorage.getItem("nop");o&&(document.documentElement.dataset.nop=o)}catch(t){console.warn("Unable to read theme from localStorage",t)}}</script><div id="root"><div class="page-wrapper  category-javascript document-page"><div class="main-wrapper"><main id="content" class="main-content  "><article class="main-page-content" lang="en-US"><header><h1>Promise.race()</h1><details class="baseline-indicator high"><summary><span class="indicator" role="img" aria-label="Baseline Check"></span><h2>Baseline<!-- --> <span class="not-bold">Widely available</span></h2><div class="browsers"><span class="engine" title="Supported in Chrome and Edge"><span class="browser chrome supported" role="img" aria-label="Chrome check"></span><span class="browser edge supported" role="img" aria-label="Edge check"></span></span><span class="engine" title="Supported in Firefox"><span class="browser firefox supported" role="img" aria-label="Firefox check"></span></span><span class="engine" title="Supported in Safari"><span class="browser safari supported" role="img" aria-label="Safari check"></span></span></div><span class="icon icon-chevron "></span></summary><div class="extra"><p>This feature is well established and works across many devices and browser versions. It’s been available across browsers since<!-- --> <!-- -->July 2015<!-- -->.</p><ul><li><a href="https://developer.mozilla.org/en-US/docs/Glossary/Baseline/Compatibility" data-glean="baseline_link_learn_more" target="_blank" class="learn-more">Learn more</a></li><li><a href="#browser_compatibility" data-glean="baseline_link_bcd_table">See full compatibility</a></li><li><a href="https://survey.alchemer.com/s3/7634825/MDN-baseline-feedback?page=%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FPromise%2Frace&amp;level=high" data-glean="baseline_link_feedback" class="feedback-link" target="_blank" rel="noreferrer">Report feedback</a></li></ul></div></details></header><div class="section-content"><p>The <strong><code>Promise.race()</code></strong> static method takes an iterable of promises as input and returns a single <a href="../Promise.html"><code>Promise</code></a>. This returned promise settles with the eventual state of the first promise that settles.</p></div><section aria-labelledby="try_it"><h2 id="try_it"><a href="#try_it">Try it</a></h2><div class="section-content"><a href="https://interactive-examples.mdn.mozilla.net/pages/js/promise-race.html">MDN Web Docs Interactive Example</a></div></section><section aria-labelledby="syntax"><h2 id="syntax"><a href="#syntax">Syntax</a></h2><div class="section-content"><div class="code-example"><div class="example-header"><span class="language-name">js</span></div><pre class="brush: js notranslate"><code>Promise.race(iterable)
</code></pre></div></div></section><section aria-labelledby="parameters"><h3 id="parameters"><a href="#parameters">Parameters</a></h3><div class="section-content"><dl>
<dt id="iterable"><a href="#iterable"><code>iterable</code></a></dt>
<dd>
<p>An <a href="../../Iteration_protocols.html#the_iterable_protocol">iterable</a> (such as an <a href="../Array.html"><code>Array</code></a>) of promises.</p>
</dd>
</dl></div></section><section aria-labelledby="return_value"><h3 id="return_value"><a href="#return_value">Return value</a></h3><div class="section-content"><p>A <a href="../Promise.html"><code>Promise</code></a> that <strong>asynchronously settles</strong> with the eventual state of the first promise in the <code>iterable</code> to settle. In other words, it fulfills if the first promise to settle is fulfilled, and rejects if the first promise to settle is rejected. The returned promise remains pending forever if the <code>iterable</code> passed is empty. If the <code>iterable</code> passed is non-empty but contains no pending promises, the returned promise is still asynchronously (instead of synchronously) settled.</p></div></section><section aria-labelledby="description"><h2 id="description"><a href="#description">Description</a></h2><div class="section-content"><p>The <code>Promise.race()</code> method is one of the <a href="../Promise.html#promise_concurrency">promise concurrency</a> methods. It's useful when you want the first async task to complete, but do not care about its eventual state (i.e. it can either succeed or fail).</p>
<p>If the iterable contains one or more non-promise values and/or an already settled promise, then <code>Promise.race()</code> will settle to the first of these values found in the iterable.</p></div></section><section aria-labelledby="examples"><h2 id="examples"><a href="#examples">Examples</a></h2><div class="section-content"></div></section><section aria-labelledby="using_promise.race"><h3 id="using_promise.race"><a href="#using_promise.race">Using Promise.race()</a></h3><div class="section-content"><p>This example shows how <code>Promise.race()</code> can be used to race several timers implemented with <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/setTimeout" title="setTimeout()"><code>setTimeout()</code></a>. The timer with the shortest time always wins the race and becomes the resulting promise's state.</p>
<div class="code-example"><div class="example-header"><span class="language-name">js</span></div><pre class="brush: js notranslate"><code>function sleep(time, value, state) {
  return new Promise((resolve, reject) =&gt; {
    setTimeout(() =&gt; {
      if (state === "fulfill") {
        return resolve(value);
      } else {
        return reject(new Error(value));
      }
    }, time);
  });
}

const p1 = sleep(500, "one", "fulfill");
const p2 = sleep(100, "two", "fulfill");

Promise.race([p1, p2]).then((value) =&gt; {
  console.log(value); // "two"
  // Both fulfill, but p2 is faster
});

const p3 = sleep(100, "three", "fulfill");
const p4 = sleep(500, "four", "reject");

Promise.race([p3, p4]).then(
  (value) =&gt; {
    console.log(value); // "three"
    // p3 is faster, so it fulfills
  },
  (error) =&gt; {
    // Not called
  },
);

const p5 = sleep(500, "five", "fulfill");
const p6 = sleep(100, "six", "reject");

Promise.race([p5, p6]).then(
  (value) =&gt; {
    // Not called
  },
  (error) =&gt; {
    console.error(error.message); // "six"
    // p6 is faster, so it rejects
  },
);
</code></pre></div></div></section><section aria-labelledby="asynchronicity_of_promise.race"><h3 id="asynchronicity_of_promise.race"><a href="#asynchronicity_of_promise.race">Asynchronicity of Promise.race</a></h3><div class="section-content"><p>This following example demonstrates the asynchronicity of <code>Promise.race</code>. Unlike other promise concurrency methods, <code>Promise.race</code> is always asynchronous: it never settles synchronously, even when the <code>iterable</code> is empty.</p>
<div class="code-example"><div class="example-header"><span class="language-name">js</span></div><pre class="brush: js notranslate"><code>// Passing an array of promises that are already resolved,
// to trigger Promise.race as soon as possible
const resolvedPromisesArray = [Promise.resolve(33), Promise.resolve(44)];

const p = Promise.race(resolvedPromisesArray);
// Immediately logging the value of p
console.log(p);

// Using setTimeout, we can execute code after the stack is empty
setTimeout(() =&gt; {
  console.log("the stack is now empty");
  console.log(p);
});

// Logs, in order:
// Promise { &lt;state&gt;: "pending" }
// the stack is now empty
// Promise { &lt;state&gt;: "fulfilled", &lt;value&gt;: 33 }
</code></pre></div>
<p>An empty iterable causes the returned promise to be forever pending:</p>
<div class="code-example"><div class="example-header"><span class="language-name">js</span></div><pre class="brush: js notranslate"><code>const foreverPendingPromise = Promise.race([]);
console.log(foreverPendingPromise);
setTimeout(() =&gt; {
  console.log("the stack is now empty");
  console.log(foreverPendingPromise);
});

// Logs, in order:
// Promise { &lt;state&gt;: "pending" }
// the stack is now empty
// Promise { &lt;state&gt;: "pending" }
</code></pre></div>
<p>If the iterable contains one or more non-promise value and/or an already settled promise, then <code>Promise.race</code> will settle to the first of these values found in the array:</p>
<div class="code-example"><div class="example-header"><span class="language-name">js</span></div><pre class="brush: js notranslate"><code>const foreverPendingPromise = Promise.race([]);
const alreadyFulfilledProm = Promise.resolve(100);

const arr = [foreverPendingPromise, alreadyFulfilledProm, "non-Promise value"];
const arr2 = [foreverPendingPromise, "non-Promise value", Promise.resolve(100)];
const p = Promise.race(arr);
const p2 = Promise.race(arr2);

console.log(p);
console.log(p2);
setTimeout(() =&gt; {
  console.log("the stack is now empty");
  console.log(p);
  console.log(p2);
});

// Logs, in order:
// Promise { &lt;state&gt;: "pending" }
// Promise { &lt;state&gt;: "pending" }
// the stack is now empty
// Promise { &lt;state&gt;: "fulfilled", &lt;value&gt;: 100 }
// Promise { &lt;state&gt;: "fulfilled", &lt;value&gt;: "non-Promise value" }
</code></pre></div></div></section><section aria-labelledby="using_promise.race_to_implement_request_timeout"><h3 id="using_promise.race_to_implement_request_timeout"><a href="#using_promise.race_to_implement_request_timeout">Using Promise.race() to implement request timeout</a></h3><div class="section-content"><p>You can race a potentially long-lasting request with a timer that rejects, so that when the time limit has elapsed, the resulting promise automatically rejects.</p>
<div class="code-example"><div class="example-header"><span class="language-name">js</span></div><pre class="brush: js notranslate"><code>const data = Promise.race([
  fetch("/api"),
  new Promise((resolve, reject) =&gt; {
    // Reject after 5 seconds
    setTimeout(() =&gt; reject(new Error("Request timed out")), 5000);
  }),
])
  .then((res) =&gt; res.json())
  .catch((err) =&gt; displayError(err));
</code></pre></div>
<p>If the <code>data</code> promise fulfills, it will contain the data fetched from <code>/api</code>; otherwise, it will reject if <code>fetch</code> remains pending for 5 seconds and loses the race with the <code>setTimeout</code> timer.</p></div></section><section aria-labelledby="using_promise.race_to_detect_the_status_of_a_promise"><h3 id="using_promise.race_to_detect_the_status_of_a_promise"><a href="#using_promise.race_to_detect_the_status_of_a_promise">Using Promise.race() to detect the status of a promise</a></h3><div class="section-content"><p>Because <code>Promise.race()</code> resolves to the first non-pending promise in the iterable, we can check a promise's state, including if it's pending. This example is adapted from <a href="https://github.com/kudla/promise-status-async/blob/master/lib/promiseState.js" class="external" target="_blank"><code>promise-status-async</code></a>.</p>
<div class="code-example"><div class="example-header"><span class="language-name">js</span></div><pre class="brush: js notranslate"><code>function promiseState(promise) {
  const pendingState = { status: "pending" };

  return Promise.race([promise, pendingState]).then(
    (value) =&gt;
      value === pendingState ? value : { status: "fulfilled", value },
    (reason) =&gt; ({ status: "rejected", reason }),
  );
}
</code></pre></div>
<p>In this function, if <code>promise</code> is pending, the second value, <code>pendingState</code>, which is a non-promise, becomes the result of the race; otherwise, if <code>promise</code> is already settled, we may know its state through the <code>onFulfilled</code> and <code>onRejected</code> handlers. For example:</p>
<div class="code-example"><div class="example-header"><span class="language-name">js</span></div><pre class="brush: js notranslate"><code>const p1 = new Promise((res) =&gt; setTimeout(() =&gt; res(100), 100));
const p2 = new Promise((res) =&gt; setTimeout(() =&gt; res(200), 200));
const p3 = new Promise((res, rej) =&gt; setTimeout(() =&gt; rej(300), 100));

async function getStates() {
  console.log(await promiseState(p1));
  console.log(await promiseState(p2));
  console.log(await promiseState(p3));
}

console.log("Immediately after initiation:");
getStates();
setTimeout(() =&gt; {
  console.log("After waiting for 100ms:");
  getStates();
}, 100);

// Logs:
// Immediately after initiation:
// { status: 'pending' }
// { status: 'pending' }
// { status: 'pending' }
// After waiting for 100ms:
// { status: 'fulfilled', value: 100 }
// { status: 'pending' }
// { status: 'rejected', reason: 300 }
</code></pre></div>
<div class="notecard note">
<p><strong>Note:</strong>
The <code>promiseState</code> function still runs asynchronously, because there is no way to synchronously get a promise's value (i.e. without <code>then()</code> or <code>await</code>), even when it is already settled. However, <code>promiseState()</code> always fulfills within one tick and never actually waits for any promise's settlement.</p>
</div></div></section><section aria-labelledby="comparison_with_promise.any"><h3 id="comparison_with_promise.any"><a href="#comparison_with_promise.any">Comparison with Promise.any()</a></h3><div class="section-content"><p><code>Promise.race</code> takes the first settled <a href="../Promise.html"><code>Promise</code></a>.</p>
<div class="code-example"><div class="example-header"><span class="language-name">js</span></div><pre class="brush: js notranslate"><code>const promise1 = new Promise((resolve, reject) =&gt; {
  setTimeout(resolve, 500, "one");
});

const promise2 = new Promise((resolve, reject) =&gt; {
  setTimeout(reject, 100, "two");
});

Promise.race([promise1, promise2])
  .then((value) =&gt; {
    console.log("succeeded with value:", value);
  })
  .catch((reason) =&gt; {
    // Only promise1 is fulfilled, but promise2 is faster
    console.error("failed with reason:", reason);
  });
// failed with reason: two
</code></pre></div>
<p><a href="any.html"><code>Promise.any</code></a> takes the first fulfilled <a href="../Promise.html"><code>Promise</code></a>.</p>
<div class="code-example"><div class="example-header"><span class="language-name">js</span></div><pre class="brush: js notranslate"><code>const promise1 = new Promise((resolve, reject) =&gt; {
  setTimeout(resolve, 500, "one");
});

const promise2 = new Promise((resolve, reject) =&gt; {
  setTimeout(reject, 100, "two");
});

Promise.any([promise1, promise2])
  .then((value) =&gt; {
    // Only promise1 is fulfilled, even though promise2 settled sooner
    console.log("succeeded with value:", value);
  })
  .catch((reason) =&gt; {
    console.error("failed with reason:", reason);
  });
// succeeded with value: one
</code></pre></div></div></section><h2 id="specifications"><a href="#specifications">Specifications</a></h2><table class="standard-table"><thead><tr><th scope="col">Specification</th></tr></thead><tbody><tr><td><a href="https://tc39.es/ecma262/multipage/control-abstraction-objects.html#sec-promise.race">ECMAScript Language Specification<!-- --> <br><small># <!-- -->sec-promise.race</small></a></td></tr></tbody></table><h2 id="browser_compatibility"><a href="#browser_compatibility">Browser compatibility</a></h2><p>BCD tables only load in the browser<noscript> <!-- -->with JavaScript enabled. Enable JavaScript to view data.</noscript></p><section aria-labelledby="see_also"><h2 id="see_also"><a href="#see_also">See also</a></h2><div class="section-content"><ul>
<li><a href="../Promise.html"><code>Promise</code></a></li>
<li><a href="all.html"><code>Promise.all()</code></a></li>
<li><a href="allSettled.html"><code>Promise.allSettled()</code></a></li>
<li><a href="any.html"><code>Promise.any()</code></a></li>
</ul></div></section></article></main></div></div></div><script type="application/json" id="hydration">{"url":"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/race","doc":{"body":[{"type":"prose","value":{"id":null,"title":null,"isH3":false,"content":"<p>The <strong><code>Promise.race()</code></strong> static method takes an iterable of promises as input and returns a single <a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise\"><code>Promise</code></a>. This returned promise settles with the eventual state of the first promise that settles.</p>"}},{"type":"prose","value":{"id":"try_it","title":"Try it","isH3":false,"content":"<iframe class=\"interactive is-taller-height\" height=\"200\" src=\"https://interactive-examples.mdn.mozilla.net/pages/js/promise-race.html\" title=\"MDN Web Docs Interactive Example\" allow=\"clipboard-write\" loading=\"lazy\"></iframe>"}},{"type":"prose","value":{"id":"syntax","title":"Syntax","isH3":false,"content":"<div class=\"code-example\"><div class=\"example-header\"><span class=\"language-name\">js</span></div><pre class=\"brush: js notranslate\"><code>Promise.race(iterable)\n</code></pre></div>"}},{"type":"prose","value":{"id":"parameters","title":"Parameters","isH3":true,"content":"<dl>\n<dt id=\"iterable\"><a href=\"#iterable\"><code>iterable</code></a></dt>\n<dd>\n<p>An <a href=\"/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#the_iterable_protocol\">iterable</a> (such as an <a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array\"><code>Array</code></a>) of promises.</p>\n</dd>\n</dl>"}},{"type":"prose","value":{"id":"return_value","title":"Return value","isH3":true,"content":"<p>A <a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise\"><code>Promise</code></a> that <strong>asynchronously settles</strong> with the eventual state of the first promise in the <code>iterable</code> to settle. In other words, it fulfills if the first promise to settle is fulfilled, and rejects if the first promise to settle is rejected. The returned promise remains pending forever if the <code>iterable</code> passed is empty. If the <code>iterable</code> passed is non-empty but contains no pending promises, the returned promise is still asynchronously (instead of synchronously) settled.</p>"}},{"type":"prose","value":{"id":"description","title":"Description","isH3":false,"content":"<p>The <code>Promise.race()</code> method is one of the <a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise#promise_concurrency\">promise concurrency</a> methods. It's useful when you want the first async task to complete, but do not care about its eventual state (i.e. it can either succeed or fail).</p>\n<p>If the iterable contains one or more non-promise values and/or an already settled promise, then <code>Promise.race()</code> will settle to the first of these values found in the iterable.</p>"}},{"type":"prose","value":{"id":"examples","title":"Examples","isH3":false,"content":""}},{"type":"prose","value":{"id":"using_promise.race","title":"Using Promise.race()","isH3":true,"content":"<p>This example shows how <code>Promise.race()</code> can be used to race several timers implemented with <a href=\"/en-US/docs/Web/API/Window/setTimeout\" title=\"setTimeout()\"><code>setTimeout()</code></a>. The timer with the shortest time always wins the race and becomes the resulting promise's state.</p>\n<div class=\"code-example\"><div class=\"example-header\"><span class=\"language-name\">js</span></div><pre class=\"brush: js notranslate\"><code>function sleep(time, value, state) {\n  return new Promise((resolve, reject) =&gt; {\n    setTimeout(() =&gt; {\n      if (state === \"fulfill\") {\n        return resolve(value);\n      } else {\n        return reject(new Error(value));\n      }\n    }, time);\n  });\n}\n\nconst p1 = sleep(500, \"one\", \"fulfill\");\nconst p2 = sleep(100, \"two\", \"fulfill\");\n\nPromise.race([p1, p2]).then((value) =&gt; {\n  console.log(value); // \"two\"\n  // Both fulfill, but p2 is faster\n});\n\nconst p3 = sleep(100, \"three\", \"fulfill\");\nconst p4 = sleep(500, \"four\", \"reject\");\n\nPromise.race([p3, p4]).then(\n  (value) =&gt; {\n    console.log(value); // \"three\"\n    // p3 is faster, so it fulfills\n  },\n  (error) =&gt; {\n    // Not called\n  },\n);\n\nconst p5 = sleep(500, \"five\", \"fulfill\");\nconst p6 = sleep(100, \"six\", \"reject\");\n\nPromise.race([p5, p6]).then(\n  (value) =&gt; {\n    // Not called\n  },\n  (error) =&gt; {\n    console.error(error.message); // \"six\"\n    // p6 is faster, so it rejects\n  },\n);\n</code></pre></div>"}},{"type":"prose","value":{"id":"asynchronicity_of_promise.race","title":"Asynchronicity of Promise.race","isH3":true,"content":"<p>This following example demonstrates the asynchronicity of <code>Promise.race</code>. Unlike other promise concurrency methods, <code>Promise.race</code> is always asynchronous: it never settles synchronously, even when the <code>iterable</code> is empty.</p>\n<div class=\"code-example\"><div class=\"example-header\"><span class=\"language-name\">js</span></div><pre class=\"brush: js notranslate\"><code>// Passing an array of promises that are already resolved,\n// to trigger Promise.race as soon as possible\nconst resolvedPromisesArray = [Promise.resolve(33), Promise.resolve(44)];\n\nconst p = Promise.race(resolvedPromisesArray);\n// Immediately logging the value of p\nconsole.log(p);\n\n// Using setTimeout, we can execute code after the stack is empty\nsetTimeout(() =&gt; {\n  console.log(\"the stack is now empty\");\n  console.log(p);\n});\n\n// Logs, in order:\n// Promise { &lt;state&gt;: \"pending\" }\n// the stack is now empty\n// Promise { &lt;state&gt;: \"fulfilled\", &lt;value&gt;: 33 }\n</code></pre></div>\n<p>An empty iterable causes the returned promise to be forever pending:</p>\n<div class=\"code-example\"><div class=\"example-header\"><span class=\"language-name\">js</span></div><pre class=\"brush: js notranslate\"><code>const foreverPendingPromise = Promise.race([]);\nconsole.log(foreverPendingPromise);\nsetTimeout(() =&gt; {\n  console.log(\"the stack is now empty\");\n  console.log(foreverPendingPromise);\n});\n\n// Logs, in order:\n// Promise { &lt;state&gt;: \"pending\" }\n// the stack is now empty\n// Promise { &lt;state&gt;: \"pending\" }\n</code></pre></div>\n<p>If the iterable contains one or more non-promise value and/or an already settled promise, then <code>Promise.race</code> will settle to the first of these values found in the array:</p>\n<div class=\"code-example\"><div class=\"example-header\"><span class=\"language-name\">js</span></div><pre class=\"brush: js notranslate\"><code>const foreverPendingPromise = Promise.race([]);\nconst alreadyFulfilledProm = Promise.resolve(100);\n\nconst arr = [foreverPendingPromise, alreadyFulfilledProm, \"non-Promise value\"];\nconst arr2 = [foreverPendingPromise, \"non-Promise value\", Promise.resolve(100)];\nconst p = Promise.race(arr);\nconst p2 = Promise.race(arr2);\n\nconsole.log(p);\nconsole.log(p2);\nsetTimeout(() =&gt; {\n  console.log(\"the stack is now empty\");\n  console.log(p);\n  console.log(p2);\n});\n\n// Logs, in order:\n// Promise { &lt;state&gt;: \"pending\" }\n// Promise { &lt;state&gt;: \"pending\" }\n// the stack is now empty\n// Promise { &lt;state&gt;: \"fulfilled\", &lt;value&gt;: 100 }\n// Promise { &lt;state&gt;: \"fulfilled\", &lt;value&gt;: \"non-Promise value\" }\n</code></pre></div>"}},{"type":"prose","value":{"id":"using_promise.race_to_implement_request_timeout","title":"Using Promise.race() to implement request timeout","isH3":true,"content":"<p>You can race a potentially long-lasting request with a timer that rejects, so that when the time limit has elapsed, the resulting promise automatically rejects.</p>\n<div class=\"code-example\"><div class=\"example-header\"><span class=\"language-name\">js</span></div><pre class=\"brush: js notranslate\"><code>const data = Promise.race([\n  fetch(\"/api\"),\n  new Promise((resolve, reject) =&gt; {\n    // Reject after 5 seconds\n    setTimeout(() =&gt; reject(new Error(\"Request timed out\")), 5000);\n  }),\n])\n  .then((res) =&gt; res.json())\n  .catch((err) =&gt; displayError(err));\n</code></pre></div>\n<p>If the <code>data</code> promise fulfills, it will contain the data fetched from <code>/api</code>; otherwise, it will reject if <code>fetch</code> remains pending for 5 seconds and loses the race with the <code>setTimeout</code> timer.</p>"}},{"type":"prose","value":{"id":"using_promise.race_to_detect_the_status_of_a_promise","title":"Using Promise.race() to detect the status of a promise","isH3":true,"content":"<p>Because <code>Promise.race()</code> resolves to the first non-pending promise in the iterable, we can check a promise's state, including if it's pending. This example is adapted from <a href=\"https://github.com/kudla/promise-status-async/blob/master/lib/promiseState.js\" class=\"external\" target=\"_blank\"><code>promise-status-async</code></a>.</p>\n<div class=\"code-example\"><div class=\"example-header\"><span class=\"language-name\">js</span></div><pre class=\"brush: js notranslate\"><code>function promiseState(promise) {\n  const pendingState = { status: \"pending\" };\n\n  return Promise.race([promise, pendingState]).then(\n    (value) =&gt;\n      value === pendingState ? value : { status: \"fulfilled\", value },\n    (reason) =&gt; ({ status: \"rejected\", reason }),\n  );\n}\n</code></pre></div>\n<p>In this function, if <code>promise</code> is pending, the second value, <code>pendingState</code>, which is a non-promise, becomes the result of the race; otherwise, if <code>promise</code> is already settled, we may know its state through the <code>onFulfilled</code> and <code>onRejected</code> handlers. For example:</p>\n<div class=\"code-example\"><div class=\"example-header\"><span class=\"language-name\">js</span></div><pre class=\"brush: js notranslate\"><code>const p1 = new Promise((res) =&gt; setTimeout(() =&gt; res(100), 100));\nconst p2 = new Promise((res) =&gt; setTimeout(() =&gt; res(200), 200));\nconst p3 = new Promise((res, rej) =&gt; setTimeout(() =&gt; rej(300), 100));\n\nasync function getStates() {\n  console.log(await promiseState(p1));\n  console.log(await promiseState(p2));\n  console.log(await promiseState(p3));\n}\n\nconsole.log(\"Immediately after initiation:\");\ngetStates();\nsetTimeout(() =&gt; {\n  console.log(\"After waiting for 100ms:\");\n  getStates();\n}, 100);\n\n// Logs:\n// Immediately after initiation:\n// { status: 'pending' }\n// { status: 'pending' }\n// { status: 'pending' }\n// After waiting for 100ms:\n// { status: 'fulfilled', value: 100 }\n// { status: 'pending' }\n// { status: 'rejected', reason: 300 }\n</code></pre></div>\n<div class=\"notecard note\">\n<p><strong>Note:</strong>\nThe <code>promiseState</code> function still runs asynchronously, because there is no way to synchronously get a promise's value (i.e. without <code>then()</code> or <code>await</code>), even when it is already settled. However, <code>promiseState()</code> always fulfills within one tick and never actually waits for any promise's settlement.</p>\n</div>"}},{"type":"prose","value":{"id":"comparison_with_promise.any","title":"Comparison with Promise.any()","isH3":true,"content":"<p><code>Promise.race</code> takes the first settled <a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise\"><code>Promise</code></a>.</p>\n<div class=\"code-example\"><div class=\"example-header\"><span class=\"language-name\">js</span></div><pre class=\"brush: js notranslate\"><code>const promise1 = new Promise((resolve, reject) =&gt; {\n  setTimeout(resolve, 500, \"one\");\n});\n\nconst promise2 = new Promise((resolve, reject) =&gt; {\n  setTimeout(reject, 100, \"two\");\n});\n\nPromise.race([promise1, promise2])\n  .then((value) =&gt; {\n    console.log(\"succeeded with value:\", value);\n  })\n  .catch((reason) =&gt; {\n    // Only promise1 is fulfilled, but promise2 is faster\n    console.error(\"failed with reason:\", reason);\n  });\n// failed with reason: two\n</code></pre></div>\n<p><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/any\"><code>Promise.any</code></a> takes the first fulfilled <a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise\"><code>Promise</code></a>.</p>\n<div class=\"code-example\"><div class=\"example-header\"><span class=\"language-name\">js</span></div><pre class=\"brush: js notranslate\"><code>const promise1 = new Promise((resolve, reject) =&gt; {\n  setTimeout(resolve, 500, \"one\");\n});\n\nconst promise2 = new Promise((resolve, reject) =&gt; {\n  setTimeout(reject, 100, \"two\");\n});\n\nPromise.any([promise1, promise2])\n  .then((value) =&gt; {\n    // Only promise1 is fulfilled, even though promise2 settled sooner\n    console.log(\"succeeded with value:\", value);\n  })\n  .catch((reason) =&gt; {\n    console.error(\"failed with reason:\", reason);\n  });\n// succeeded with value: one\n</code></pre></div>"}},{"type":"specifications","value":{"id":"specifications","title":"Specifications","isH3":false,"specifications":[{"bcdSpecificationURL":"https://tc39.es/ecma262/multipage/control-abstraction-objects.html#sec-promise.race","title":"ECMAScript Language Specification"}],"query":"javascript.builtins.Promise.race"}},{"type":"browser_compatibility","value":{"id":"browser_compatibility","title":"Browser compatibility","isH3":false,"query":"javascript.builtins.Promise.race"}},{"type":"prose","value":{"id":"see_also","title":"See also","isH3":false,"content":"<ul>\n<li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise\"><code>Promise</code></a></li>\n<li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all\"><code>Promise.all()</code></a></li>\n<li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/allSettled\"><code>Promise.allSettled()</code></a></li>\n<li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/any\"><code>Promise.any()</code></a></li>\n</ul>"}}],"isActive":true,"isMarkdown":true,"isTranslated":false,"locale":"en-US","mdn_url":"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/race","modified":"2024-10-07T09:37:56.000Z","native":"English (US)","noIndexing":false,"other_translations":[{"locale":"de","title":"Promise.race()","native":"Deutsch"},{"locale":"es","title":"Promise.race()","native":"Español"},{"locale":"fr","title":"Promise.race()","native":"Français"},{"locale":"ja","title":"Promise.race()","native":"日本語"},{"locale":"ko","title":"Promise.race()","native":"한국어"},{"locale":"pt-BR","title":"Promise.race()","native":"Português (do Brasil)"},{"locale":"ru","title":"Promise.race()","native":"Русский"},{"locale":"zh-CN","title":"Promise.race()","native":"中文 (简体)"},{"locale":"zh-TW","title":"Promise.race()","native":"正體中文 (繁體)"}],"pageTitle":"Promise.race() - JavaScript | MDN","parents":[{"uri":"/en-US/docs/Web","title":"References"},{"uri":"/en-US/docs/Web/JavaScript","title":"JavaScript"},{"uri":"/en-US/docs/Web/JavaScript/Reference","title":"Reference"},{"uri":"/en-US/docs/Web/JavaScript/Reference/Global_Objects","title":"Standard built-in objects"},{"uri":"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise","title":"Promise"},{"uri":"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/race","title":"Promise.race()"}],"popularity":null,"short_title":"Promise.race()","sidebarHTML":"<ol><li class=\"section\"><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects\">Standard built-in objects</a></li><li class=\"section\"><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise\"><code>Promise</code></a></li><li class=\"toggle\"><details open=\"\"><summary>Constructor</summary><ol><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/Promise\"><code>Promise() constructor</code></a></li></ol></details></li><li class=\"toggle\"><details open=\"\"><summary>Static methods</summary><ol><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all\"><code>Promise.all()</code></a></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/allSettled\"><code>Promise.allSettled()</code></a></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/any\"><code>Promise.any()</code></a></li><li><em><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/race\" aria-current=\"page\"><code>Promise.race()</code></a></em></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/reject\"><code>Promise.reject()</code></a></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/resolve\"><code>Promise.resolve()</code></a></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/try\"><code>Promise.try()</code></a></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/withResolvers\"><code>Promise.withResolvers()</code></a></li></ol></details></li><li class=\"toggle\"><details open=\"\"><summary>Static properties</summary><ol><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/Symbol.species\"><code>Promise[Symbol.species]</code></a></li></ol></details></li><li class=\"toggle\"><details open=\"\"><summary>Instance methods</summary><ol><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/catch\"><code>Promise.prototype.catch()</code></a></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/finally\"><code>Promise.prototype.finally()</code></a></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then\"><code>Promise.prototype.then()</code></a></li></ol></details></li><li class=\"section\">Inheritance</li><li class=\"section\"><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object\"><code>Object/Function</code></a></li><li class=\"toggle\"><details><summary>Static methods</summary><ol><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply\"><code>Function.prototype.apply()</code></a></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind\"><code>Function.prototype.bind()</code></a></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call\"><code>Function.prototype.call()</code></a></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/toString\"><code>Function.prototype.toString()</code></a></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/Symbol.hasInstance\"><code>Function.prototype[Symbol.hasInstance]()</code></a></li></ol></details></li><li class=\"toggle\"><details><summary>Static properties</summary><ol><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/displayName\"><code>Function: displayName</code></a><abbr class=\"icon icon-nonstandard\" title=\"Non-standard. Check cross-browser support before using.\">\n<span class=\"visually-hidden\">Non-standard</span>\n</abbr></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/length\"><code>Function: length</code></a></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name\"><code>Function: name</code></a></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/prototype\"><code>Function: prototype</code></a></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/arguments\"><code>Function.prototype.arguments</code></a><abbr class=\"icon icon-nonstandard\" title=\"Non-standard. Check cross-browser support before using.\">\n<span class=\"visually-hidden\">Non-standard</span>\n</abbr><abbr class=\"icon icon-deprecated\" title=\"Deprecated. Not for use in new websites.\">\n<span class=\"visually-hidden\">Deprecated</span>\n</abbr></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/caller\"><code>Function.prototype.caller</code></a><abbr class=\"icon icon-nonstandard\" title=\"Non-standard. Check cross-browser support before using.\">\n<span class=\"visually-hidden\">Non-standard</span>\n</abbr><abbr class=\"icon icon-deprecated\" title=\"Deprecated. Not for use in new websites.\">\n<span class=\"visually-hidden\">Deprecated</span>\n</abbr></li></ol></details></li><li class=\"toggle\"><details><summary>Instance methods</summary><ol><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/__defineGetter__\"><code>Object.prototype.__defineGetter__()</code></a><abbr class=\"icon icon-deprecated\" title=\"Deprecated. Not for use in new websites.\">\n<span class=\"visually-hidden\">Deprecated</span>\n</abbr></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/__defineSetter__\"><code>Object.prototype.__defineSetter__()</code></a><abbr class=\"icon icon-deprecated\" title=\"Deprecated. Not for use in new websites.\">\n<span class=\"visually-hidden\">Deprecated</span>\n</abbr></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/__lookupGetter__\"><code>Object.prototype.__lookupGetter__()</code></a><abbr class=\"icon icon-deprecated\" title=\"Deprecated. Not for use in new websites.\">\n<span class=\"visually-hidden\">Deprecated</span>\n</abbr></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/__lookupSetter__\"><code>Object.prototype.__lookupSetter__()</code></a><abbr class=\"icon icon-deprecated\" title=\"Deprecated. Not for use in new websites.\">\n<span class=\"visually-hidden\">Deprecated</span>\n</abbr></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty\"><code>Object.prototype.hasOwnProperty()</code></a></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isPrototypeOf\"><code>Object.prototype.isPrototypeOf()</code></a></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/propertyIsEnumerable\"><code>Object.prototype.propertyIsEnumerable()</code></a></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/toLocaleString\"><code>Object.prototype.toLocaleString()</code></a></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/toString\"><code>Object.prototype.toString()</code></a></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/valueOf\"><code>Object.prototype.valueOf()</code></a></li></ol></details></li><li class=\"toggle\"><details><summary>Instance properties</summary><ol><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/proto\"><code>Object.prototype.__proto__</code></a><abbr class=\"icon icon-deprecated\" title=\"Deprecated. Not for use in new websites.\">\n<span class=\"visually-hidden\">Deprecated</span>\n</abbr></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/constructor\"><code>Object.prototype.constructor</code></a></li></ol></details></li></ol>","source":{"folder":"en-us/web/javascript/reference/global_objects/promise/race","github_url":"https://github.com/mdn/content/blob/main/files/en-us/web/javascript/reference/global_objects/promise/race/index.md","last_commit_url":"https://github.com/mdn/content/commit/1b4e6d1156e8471d38deeea1567c35ef412c5f42","filename":"index.md"},"summary":"The Promise.race() static method takes an iterable of promises as input and returns a single Promise. This returned promise settles with the eventual state of the first promise that settles.","title":"Promise.race()","toc":[{"text":"Try it","id":"try_it"},{"text":"Syntax","id":"syntax"},{"text":"Description","id":"description"},{"text":"Examples","id":"examples"},{"text":"Specifications","id":"specifications"},{"text":"Browser compatibility","id":"browser_compatibility"},{"text":"See also","id":"see_also"}],"baseline":{"baseline":"high","baseline_low_date":"2015-07-29","baseline_high_date":"2018-01-29","support":{"chrome":"32","chrome_android":"32","edge":"12","firefox":"29","firefox_android":"29","safari":"8","safari_ios":"8"}},"browserCompat":["javascript.builtins.Promise.race"],"pageType":"javascript-static-method"}}</script>

</body><!-- Mirrored from developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/race by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 08 Jan 2025 13:10:17 GMT --></html>