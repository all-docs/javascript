<!DOCTYPE html><html lang="en-US" prefix="og: https://ogp.me/ns#"><!-- Mirrored from developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 08 Jan 2025 13:10:17 GMT --><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="icon" href="https://developer.mozilla.org/favicon-48x48.bc390275e955dacb2e65.png"><link rel="apple-touch-icon" href="https://developer.mozilla.org/apple-touch-icon.528534bba673c38049c2.png"><meta name="theme-color" content="#ffffff"><link rel="manifest" href="https://developer.mozilla.org/manifest.f42880861b394dd4dc9b.json"><link rel="search" type="application/opensearchdescription+xml" href="https://developer.mozilla.org/opensearch.xml" title="MDN Web Docs"><title>Promise.prototype.then()</title><link rel="alternate" title="Promise.prototype.then()" href="https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Promise/then" hreflang="de"><link rel="alternate" title="Promise.prototype.then()" href="https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Promise/then" hreflang="es"><link rel="alternate" title="Promise.prototype.then()" href="https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Global_Objects/Promise/then" hreflang="fr"><link rel="alternate" title="Promise.prototype.then()" href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Promise/then" hreflang="ja"><link rel="alternate" title="Promise.prototype.then()" href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Promise/then" hreflang="ko"><link rel="alternate" title="Promise.prototype.then()" href="https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Reference/Global_Objects/Promise/then" hreflang="pt"><link rel="alternate" title="Promise.prototype.then()" href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Promise/then" hreflang="ru"><link rel="alternate" title="Promise.prototype.then()" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/then" hreflang="zh"><link rel="alternate" title="Promise.prototype.then()" href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Promise/then" hreflang="zh-Hant"><link rel="alternate" title="Promise.prototype.then()" href="then.html" hreflang="en"><link rel="preload" as="font" type="font/woff2" href="https://developer.mozilla.org/static/media/Inter.var.c2fe3cb2b7c746f7966a.woff2" crossorigin=""><link rel="alternate" type="application/rss+xml" title="MDN Blog RSS Feed" href="https://developer.mozilla.org/en-US/blog/rss.xml" hreflang="en"><meta name="description" content="The then() method of Promise instances takes up to two arguments: callback functions for the fulfilled and rejected cases of the Promise. It stores the callbacks within the promise it is called on and immediately returns another Promise object, allowing you to chain calls to other promise methods."><meta property="og:url" content="then.html"><meta property="og:title" content="Promise.prototype.then() - JavaScript | MDN"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:description" content="The then() method of Promise instances takes up to two arguments: callback functions for the fulfilled and rejected cases of the Promise. It stores the callbacks within the promise it is called on and immediately returns another Promise object, allowing you to chain calls to other promise methods."><meta property="og:image" content="https://developer.mozilla.org/mdn-social-share.d893525a4fb5fb1f67a2.png"><meta property="og:image:type" content="image/png"><meta property="og:image:height" content="1080"><meta property="og:image:width" content="1920"><meta property="og:image:alt" content="The MDN Web Docs logo, featuring a blue accent color, displayed on a solid black background."><meta property="og:site_name" content="MDN Web Docs"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:creator" content="MozDevNet"><link rel="canonical" href="then.html"><style media="print">.article-actions-container,.document-toc-container,.language-menu,.main-menu-toggle,.on-github,.page-footer,.place,.sidebar,.top-banner,.top-navigation-main,ul.prev-next{display:none!important}.main-page-content,.main-page-content pre{padding:2px}.main-page-content pre{border-left-width:2px}</style><link href="https://developer.mozilla.org/static/css/main.65aa8eed.css" rel="stylesheet"></head><body><script>if(document.body.addEventListener("load",(t=>{t.target.classList.contains("interactive")&&t.target.setAttribute("data-readystate","complete")}),{capture:!0}),window&&document.documentElement){const t={light:"#ffffff",dark:"#1b1b1b"};try{const e=window.localStorage.getItem("theme");e&&(document.documentElement.className=e,document.documentElement.style.backgroundColor=t[e]);const o=window.localStorage.getItem("nop");o&&(document.documentElement.dataset.nop=o)}catch(t){console.warn("Unable to read theme from localStorage",t)}}</script><div id="root"><div class="page-wrapper  category-javascript document-page"><div class="main-wrapper"><main id="content" class="main-content  "><article class="main-page-content" lang="en-US"><header><h1>Promise.prototype.then()</h1><details class="baseline-indicator high"><summary><span class="indicator" role="img" aria-label="Baseline Check"></span><h2>Baseline<!-- --> <span class="not-bold">Widely available</span></h2><div class="browsers"><span class="engine" title="Supported in Chrome and Edge"><span class="browser chrome supported" role="img" aria-label="Chrome check"></span><span class="browser edge supported" role="img" aria-label="Edge check"></span></span><span class="engine" title="Supported in Firefox"><span class="browser firefox supported" role="img" aria-label="Firefox check"></span></span><span class="engine" title="Supported in Safari"><span class="browser safari supported" role="img" aria-label="Safari check"></span></span></div><span class="icon icon-chevron "></span></summary><div class="extra"><p>This feature is well established and works across many devices and browser versions. It’s been available across browsers since<!-- --> <!-- -->July 2015<!-- -->.</p><ul><li><a href="https://developer.mozilla.org/en-US/docs/Glossary/Baseline/Compatibility" data-glean="baseline_link_learn_more" target="_blank" class="learn-more">Learn more</a></li><li><a href="#browser_compatibility" data-glean="baseline_link_bcd_table">See full compatibility</a></li><li><a href="https://survey.alchemer.com/s3/7634825/MDN-baseline-feedback?page=%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FPromise%2Fthen&amp;level=high" data-glean="baseline_link_feedback" class="feedback-link" target="_blank" rel="noreferrer">Report feedback</a></li></ul></div></details></header><div class="section-content"><p>The <strong><code>then()</code></strong> method of <a href="../Promise.html"><code>Promise</code></a> instances takes up to two arguments: callback functions for the fulfilled and rejected cases of the <code>Promise</code>. It stores the callbacks within the promise it is called on and immediately returns another <a href="../Promise.html"><code>Promise</code></a> object, allowing you to <a href="../../../Guide/Using_promises.html#chaining">chain</a> calls to other promise methods.</p></div><section aria-labelledby="try_it"><h2 id="try_it"><a href="#try_it">Try it</a></h2><div class="section-content"><iframe class="interactive is-js-height" height="200" src="https://interactive-examples.mdn.mozilla.net/pages/js/promise-then.html" title="MDN Web Docs Interactive Example" allow="clipboard-write" loading="lazy"></iframe></div></section><section aria-labelledby="syntax"><h2 id="syntax"><a href="#syntax">Syntax</a></h2><div class="section-content"><div class="code-example"><div class="example-header"><span class="language-name">js</span></div><pre class="brush: js notranslate"><code>then(onFulfilled)
then(onFulfilled, onRejected)
</code></pre></div></div></section><section aria-labelledby="parameters"><h3 id="parameters"><a href="#parameters">Parameters</a></h3><div class="section-content"><dl>
<dt id="onfulfilled"><a href="#onfulfilled"><code>onFulfilled</code></a></dt>
<dd>
<p>A function to asynchronously execute when this promise becomes fulfilled. Its return value becomes the fulfillment value of the promise returned by <code>then()</code>. The function is called with the following arguments:</p>
<dl>
<dt id="value"><a href="#value"><code>value</code></a></dt>
<dd>
<p>The value that the promise was fulfilled with.</p>
</dd>
</dl>
<p>If it is not a function, it is internally replaced with an <em>identity</em> function (<code>(x) =&gt; x</code>) which simply passes the fulfillment value forward.</p>
</dd>
<dt id="onrejected"><a href="#onrejected"><code>onRejected</code> <span class="badge inline optional">Optional</span></a></dt>
<dd>
<p>A function to asynchronously execute when this promise becomes rejected. Its return value becomes the fulfillment value of the promise returned by <code>then()</code>. The function is called with the following arguments:</p>
<dl>
<dt id="reason"><a href="#reason"><code>reason</code></a></dt>
<dd>
<p>The value that the promise was rejected with.</p>
</dd>
</dl>
<p>If it is not a function, it is internally replaced with a <em>thrower</em> function (<code>(x) =&gt; { throw x; }</code>) which throws the rejection reason it received.</p>
</dd>
</dl></div></section><section aria-labelledby="return_value"><h3 id="return_value"><a href="#return_value">Return value</a></h3><div class="section-content"><p>Returns a new <a href="../Promise.html"><code>Promise</code></a> immediately. This new promise is always pending when returned, regardless of the current promise's status.</p>
<p>One of the <code>onFulfilled</code> and <code>onRejected</code> handlers will be executed to handle the current promise's fulfillment or rejection. The call always happens asynchronously, even when the current promise is already settled. The behavior of the returned promise (call it <code>p</code>) depends on the handler's execution result, following a specific set of rules. If the handler function:</p>
<ul>
<li>returns a value: <code>p</code> gets fulfilled with the returned value as its value.</li>
<li>doesn't return anything: <code>p</code> gets fulfilled with <code>undefined</code> as its value.</li>
<li>throws an error: <code>p</code> gets rejected with the thrown error as its value.</li>
<li>returns an already fulfilled promise: <code>p</code> gets fulfilled with that promise's value as its value.</li>
<li>returns an already rejected promise: <code>p</code> gets rejected with that promise's value as its value.</li>
<li>returns another pending promise: <code>p</code> is pending and becomes fulfilled/rejected with that promise's value as its value immediately after that promise becomes fulfilled/rejected.</li>
</ul></div></section><section aria-labelledby="description"><h2 id="description"><a href="#description">Description</a></h2><div class="section-content"><p>The <code>then()</code> method schedules callback functions for the eventual completion of a Promise — either fulfillment or rejection. It is the primitive method of promises: the <a href="../Promise.html#thenables">thenable</a> protocol expects all promise-like objects to expose a <code>then()</code> method, and the <a href="catch.html"><code>catch()</code></a> and <a href="finally.html"><code>finally()</code></a> methods both work by invoking the object's <code>then()</code> method.</p>
<p>For more information about the <code>onRejected</code> handler, see the <a href="catch.html"><code>catch()</code></a> reference.</p>
<p><code>then()</code> returns a new promise object but mutates the promise object it's called on, appending the handlers to an internal list. Therefore the handler is retained by the original promise and its lifetime is at least as long as the original promise's lifetime. For example, the following example will eventually run out of memory even though the returned promise is not retained:</p>
<div class="code-example"><div class="example-header"><span class="language-name">js</span></div><pre class="brush: js notranslate"><code>const pendingPromise = new Promise(() =&gt; {});
while (true) {
  pendingPromise.then(doSomething);
}
</code></pre></div>
<p>If you call the <code>then()</code> method twice on the same promise object (instead of chaining), then this promise object will have two pairs of settlement handlers. All handlers attached to the same promise object are always called in the order they were added. Moreover, the two promises returned by each call of <code>then()</code> start separate chains and do not wait for each other's settlement.</p>
<p><a href="../Promise.html#thenables">Thenable</a> objects that arise along the <code>then()</code> chain are always <a href="Promise.html#the_resolve_function">resolved</a> — the <code>onFulfilled</code> handler never receives a thenable object, and any thenable returned by either handler are always resolved before being passed to the next handler. This is because when constructing the new promise, the <code>resolve</code> and <code>reject</code> functions passed by the <code>executor</code> are saved, and when the current promise settles, the respective function will be called with the fulfillment value or rejection reason. The resolving logic comes from the <code>resolve</code> function passed by the <a href="Promise.html"><code>Promise()</code></a> constructor.</p>
<p><code>then()</code> supports subclassing, which means it can be called on instances of subclasses of <code>Promise</code>, and the result will be a promise of the subclass type. You can customize the type of the return value through the <a href="Symbol.html"><code>[Symbol.species]</code></a> property.</p></div></section><section aria-labelledby="examples"><h2 id="examples"><a href="#examples">Examples</a></h2><div class="section-content"></div></section><section aria-labelledby="using_the_then_method"><h3 id="using_the_then_method"><a href="#using_the_then_method">Using the then() method</a></h3><div class="section-content"><div class="code-example"><div class="example-header"><span class="language-name">js</span></div><pre class="brush: js notranslate"><code>const p1 = new Promise((resolve, reject) =&gt; {
  resolve("Success!");
  // or
  // reject(new Error("Error!"));
});

p1.then(
  (value) =&gt; {
    console.log(value); // Success!
  },
  (reason) =&gt; {
    console.error(reason); // Error!
  },
);
</code></pre></div></div></section><section aria-labelledby="having_a_non-function_as_either_parameter"><h3 id="having_a_non-function_as_either_parameter"><a href="#having_a_non-function_as_either_parameter">Having a non-function as either parameter</a></h3><div class="section-content"><div class="code-example"><div class="example-header"><span class="language-name">js</span></div><pre class="brush: js notranslate"><code>Promise.resolve(1).then(2).then(console.log); // 1
Promise.reject(1).then(2, 2).then(console.log, console.log); // 1
</code></pre></div></div></section><section aria-labelledby="chaining"><h3 id="chaining"><a href="#chaining">Chaining</a></h3><div class="section-content"><p>The <code>then</code> method returns a new <code>Promise</code>, which allows for method chaining.</p>
<p>If the function passed as handler to <code>then</code> returns a <code>Promise</code>, an equivalent <code>Promise</code> will be exposed to the subsequent <code>then</code> in the method chain. The below snippet simulates asynchronous code with the <code>setTimeout</code> function.</p>
<div class="code-example"><div class="example-header"><span class="language-name">js</span></div><pre class="brush: js notranslate"><code>Promise.resolve("foo")
  // 1. Receive "foo", concatenate "bar" to it, and resolve that to the next then
  .then(
    (string) =&gt;
      new Promise((resolve, reject) =&gt; {
        setTimeout(() =&gt; {
          string += "bar";
          resolve(string);
        }, 1);
      }),
  )
  // 2. receive "foobar", register a callback function to work on that string
  // and print it to the console, but not before returning the unworked on
  // string to the next then
  .then((string) =&gt; {
    setTimeout(() =&gt; {
      string += "baz";
      console.log(string); // foobarbaz
    }, 1);
    return string;
  })
  // 3. print helpful messages about how the code in this section will be run
  // before the string is actually processed by the mocked asynchronous code in the
  // previous then block.
  .then((string) =&gt; {
    console.log(
      "Last Then: oops... didn't bother to instantiate and return a promise in the prior then so the sequence may be a bit surprising",
    );

    // Note that `string` will not have the 'baz' bit of it at this point. This
    // is because we mocked that to happen asynchronously with a setTimeout function
    console.log(string); // foobar
  });

// Logs, in order:
// Last Then: oops... didn't bother to instantiate and return a promise in the prior then so the sequence may be a bit surprising
// foobar
// foobarbaz
</code></pre></div>
<p>The value returned from <code>then()</code> is resolved in the same way as <a href="resolve.html"><code>Promise.resolve()</code></a>. This means <a href="../Promise.html#thenables">thenable objects</a> are supported, and if the return value is not a promise, it's implicitly wrapped in a <code>Promise</code> and then resolved.</p>
<div class="code-example"><div class="example-header"><span class="language-name">js</span></div><pre class="brush: js notranslate"><code>const p2 = new Promise((resolve, reject) =&gt; {
  resolve(1);
});

p2.then((value) =&gt; {
  console.log(value); // 1
  return value + 1;
}).then((value) =&gt; {
  console.log(value, "- A synchronous value works"); // 2 - A synchronous value works
});

p2.then((value) =&gt; {
  console.log(value); // 1
});
</code></pre></div>
<p>A <code>then</code> call returns a promise that eventually rejects if the function throws an error or returns a rejected Promise.</p>
<div class="code-example"><div class="example-header"><span class="language-name">js</span></div><pre class="brush: js notranslate"><code>Promise.resolve()
  .then(() =&gt; {
    // Makes .then() return a rejected promise
    throw new Error("Oh no!");
  })
  .then(
    () =&gt; {
      console.log("Not called.");
    },
    (error) =&gt; {
      console.error(`onRejected function called: ${error.message}`);
    },
  );
</code></pre></div>
<p>In practice, it is often desirable to <a href="catch.html"><code>catch()</code></a> rejected promises rather than <code>then()</code>'s two-case syntax, as demonstrated below.</p>
<div class="code-example"><div class="example-header"><span class="language-name">js</span></div><pre class="brush: js notranslate"><code>Promise.resolve()
  .then(() =&gt; {
    // Makes .then() return a rejected promise
    throw new Error("Oh no!");
  })
  .catch((error) =&gt; {
    console.error(`onRejected function called: ${error.message}`);
  })
  .then(() =&gt; {
    console.log("I am always called even if the prior then's promise rejects");
  });
</code></pre></div>
<p>In all other cases, the returned promise eventually fulfills. In the following example, the first <code>then()</code> returns <code>42</code> wrapped in a fulfilled Promise, even though the previous Promise in the chain was rejected.</p>
<div class="code-example"><div class="example-header"><span class="language-name">js</span></div><pre class="brush: js notranslate"><code>Promise.reject()
  .then(
    () =&gt; 99,
    () =&gt; 42,
  ) // onRejected returns 42 which is wrapped in a fulfilled Promise
  .then((solution) =&gt; console.log(`Resolved with ${solution}`)); // Fulfilled with 42
</code></pre></div>
<p>If <code>onFulfilled</code> returns a promise, the return value of <code>then</code> will be fulfilled/rejected based on the eventual state of that promise.</p>
<div class="code-example"><div class="example-header"><span class="language-name">js</span></div><pre class="brush: js notranslate"><code>function resolveLater(resolve, reject) {
  setTimeout(() =&gt; {
    resolve(10);
  }, 1000);
}
function rejectLater(resolve, reject) {
  setTimeout(() =&gt; {
    reject(new Error("Error"));
  }, 1000);
}

const p1 = Promise.resolve("foo");
const p2 = p1.then(() =&gt; {
  // Return promise here, that will be resolved to 10 after 1 second
  return new Promise(resolveLater);
});
p2.then(
  (v) =&gt; {
    console.log("resolved", v); // "resolved", 10
  },
  (e) =&gt; {
    // not called
    console.error("rejected", e);
  },
);

const p3 = p1.then(() =&gt; {
  // Return promise here, that will be rejected with 'Error' after 1 second
  return new Promise(rejectLater);
});
p3.then(
  (v) =&gt; {
    // not called
    console.log("resolved", v);
  },
  (e) =&gt; {
    console.error("rejected", e); // "rejected", 'Error'
  },
);
</code></pre></div>
<p>You can use chaining to implement one function with a Promise-based API on top of another such function.</p>
<div class="code-example"><div class="example-header"><span class="language-name">js</span></div><pre class="brush: js notranslate"><code>function fetchCurrentData() {
  // The fetch() API returns a Promise. This function
  // exposes a similar API, except the fulfillment
  // value of this function's Promise has had more
  // work done on it.
  return fetch("current-data.json").then((response) =&gt; {
    if (response.headers.get("content-type") !== "application/json") {
      throw new TypeError();
    }
    const j = response.json();
    // maybe do something with j

    // fulfillment value given to user of
    // fetchCurrentData().then()
    return j;
  });
}
</code></pre></div></div></section><section aria-labelledby="asynchronicity_of_then"><h3 id="asynchronicity_of_then"><a href="#asynchronicity_of_then">Asynchronicity of then()</a></h3><div class="section-content"><p>The following is an example to demonstrate the asynchronicity of the <code>then</code> method.</p>
<div class="code-example"><div class="example-header"><span class="language-name">js</span></div><pre class="brush: js notranslate"><code>// Using a resolved promise 'resolvedProm' for example,
// the function call 'resolvedProm.then(...)' returns a new promise immediately,
// but its handler '(value) =&gt; {...}' will get called asynchronously as demonstrated by the console.logs.
// the new promise is assigned to 'thenProm',
// and thenProm will be resolved with the value returned by handler
const resolvedProm = Promise.resolve(33);
console.log(resolvedProm);

const thenProm = resolvedProm.then((value) =&gt; {
  console.log(
    `this gets called after the end of the main stack. the value received is: ${value}, the value returned is: ${
      value + 1
    }`,
  );
  return value + 1;
});
console.log(thenProm);

// Using setTimeout, we can postpone the execution of a function to the moment the stack is empty
setTimeout(() =&gt; {
  console.log(thenProm);
});

// Logs, in order:
// Promise {[[PromiseStatus]]: "resolved", [[PromiseResult]]: 33}
// Promise {[[PromiseStatus]]: "pending", [[PromiseResult]]: undefined}
// "this gets called after the end of the main stack. the value received is: 33, the value returned is: 34"
// Promise {[[PromiseStatus]]: "resolved", [[PromiseResult]]: 34}
</code></pre></div></div></section><h2 id="specifications"><a href="#specifications">Specifications</a></h2><table class="standard-table"><thead><tr><th scope="col">Specification</th></tr></thead><tbody><tr><td><a href="https://tc39.es/ecma262/multipage/control-abstraction-objects.html#sec-promise.prototype.then">ECMAScript Language Specification<!-- --> <br><small># <!-- -->sec-promise.prototype.then</small></a></td></tr></tbody></table><h2 id="browser_compatibility"><a href="#browser_compatibility">Browser compatibility</a></h2><p>BCD tables only load in the browser<noscript> <!-- -->with JavaScript enabled. Enable JavaScript to view data.</noscript></p><section aria-labelledby="see_also"><h2 id="see_also"><a href="#see_also">See also</a></h2><div class="section-content"><ul>
<li><a href="../Promise.html"><code>Promise</code></a></li>
<li><a href="catch.html"><code>Promise.prototype.catch()</code></a></li>
</ul></div></section></article></main></div></div></div><script type="application/json" id="hydration">{"url":"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then","doc":{"body":[{"type":"prose","value":{"id":null,"title":null,"isH3":false,"content":"<p>The <strong><code>then()</code></strong> method of <a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise\"><code>Promise</code></a> instances takes up to two arguments: callback functions for the fulfilled and rejected cases of the <code>Promise</code>. It stores the callbacks within the promise it is called on and immediately returns another <a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise\"><code>Promise</code></a> object, allowing you to <a href=\"/en-US/docs/Web/JavaScript/Guide/Using_promises#chaining\">chain</a> calls to other promise methods.</p>"}},{"type":"prose","value":{"id":"try_it","title":"Try it","isH3":false,"content":"<iframe class=\"interactive is-js-height\" height=\"200\" src=\"https://interactive-examples.mdn.mozilla.net/pages/js/promise-then.html\" title=\"MDN Web Docs Interactive Example\" allow=\"clipboard-write\" loading=\"lazy\"></iframe>"}},{"type":"prose","value":{"id":"syntax","title":"Syntax","isH3":false,"content":"<div class=\"code-example\"><div class=\"example-header\"><span class=\"language-name\">js</span></div><pre class=\"brush: js notranslate\"><code>then(onFulfilled)\nthen(onFulfilled, onRejected)\n</code></pre></div>"}},{"type":"prose","value":{"id":"parameters","title":"Parameters","isH3":true,"content":"<dl>\n<dt id=\"onfulfilled\"><a href=\"#onfulfilled\"><code>onFulfilled</code></a></dt>\n<dd>\n<p>A function to asynchronously execute when this promise becomes fulfilled. Its return value becomes the fulfillment value of the promise returned by <code>then()</code>. The function is called with the following arguments:</p>\n<dl>\n<dt id=\"value\"><a href=\"#value\"><code>value</code></a></dt>\n<dd>\n<p>The value that the promise was fulfilled with.</p>\n</dd>\n</dl>\n<p>If it is not a function, it is internally replaced with an <em>identity</em> function (<code>(x) =&gt; x</code>) which simply passes the fulfillment value forward.</p>\n</dd>\n<dt id=\"onrejected\"><a href=\"#onrejected\"><code>onRejected</code> <span class=\"badge inline optional\">Optional</span></a></dt>\n<dd>\n<p>A function to asynchronously execute when this promise becomes rejected. Its return value becomes the fulfillment value of the promise returned by <code>then()</code>. The function is called with the following arguments:</p>\n<dl>\n<dt id=\"reason\"><a href=\"#reason\"><code>reason</code></a></dt>\n<dd>\n<p>The value that the promise was rejected with.</p>\n</dd>\n</dl>\n<p>If it is not a function, it is internally replaced with a <em>thrower</em> function (<code>(x) =&gt; { throw x; }</code>) which throws the rejection reason it received.</p>\n</dd>\n</dl>"}},{"type":"prose","value":{"id":"return_value","title":"Return value","isH3":true,"content":"<p>Returns a new <a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise\"><code>Promise</code></a> immediately. This new promise is always pending when returned, regardless of the current promise's status.</p>\n<p>One of the <code>onFulfilled</code> and <code>onRejected</code> handlers will be executed to handle the current promise's fulfillment or rejection. The call always happens asynchronously, even when the current promise is already settled. The behavior of the returned promise (call it <code>p</code>) depends on the handler's execution result, following a specific set of rules. If the handler function:</p>\n<ul>\n<li>returns a value: <code>p</code> gets fulfilled with the returned value as its value.</li>\n<li>doesn't return anything: <code>p</code> gets fulfilled with <code>undefined</code> as its value.</li>\n<li>throws an error: <code>p</code> gets rejected with the thrown error as its value.</li>\n<li>returns an already fulfilled promise: <code>p</code> gets fulfilled with that promise's value as its value.</li>\n<li>returns an already rejected promise: <code>p</code> gets rejected with that promise's value as its value.</li>\n<li>returns another pending promise: <code>p</code> is pending and becomes fulfilled/rejected with that promise's value as its value immediately after that promise becomes fulfilled/rejected.</li>\n</ul>"}},{"type":"prose","value":{"id":"description","title":"Description","isH3":false,"content":"<p>The <code>then()</code> method schedules callback functions for the eventual completion of a Promise — either fulfillment or rejection. It is the primitive method of promises: the <a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise#thenables\">thenable</a> protocol expects all promise-like objects to expose a <code>then()</code> method, and the <a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/catch\"><code>catch()</code></a> and <a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/finally\"><code>finally()</code></a> methods both work by invoking the object's <code>then()</code> method.</p>\n<p>For more information about the <code>onRejected</code> handler, see the <a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/catch\"><code>catch()</code></a> reference.</p>\n<p><code>then()</code> returns a new promise object but mutates the promise object it's called on, appending the handlers to an internal list. Therefore the handler is retained by the original promise and its lifetime is at least as long as the original promise's lifetime. For example, the following example will eventually run out of memory even though the returned promise is not retained:</p>\n<div class=\"code-example\"><div class=\"example-header\"><span class=\"language-name\">js</span></div><pre class=\"brush: js notranslate\"><code>const pendingPromise = new Promise(() =&gt; {});\nwhile (true) {\n  pendingPromise.then(doSomething);\n}\n</code></pre></div>\n<p>If you call the <code>then()</code> method twice on the same promise object (instead of chaining), then this promise object will have two pairs of settlement handlers. All handlers attached to the same promise object are always called in the order they were added. Moreover, the two promises returned by each call of <code>then()</code> start separate chains and do not wait for each other's settlement.</p>\n<p><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise#thenables\">Thenable</a> objects that arise along the <code>then()</code> chain are always <a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/Promise#the_resolve_function\">resolved</a> — the <code>onFulfilled</code> handler never receives a thenable object, and any thenable returned by either handler are always resolved before being passed to the next handler. This is because when constructing the new promise, the <code>resolve</code> and <code>reject</code> functions passed by the <code>executor</code> are saved, and when the current promise settles, the respective function will be called with the fulfillment value or rejection reason. The resolving logic comes from the <code>resolve</code> function passed by the <a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/Promise\"><code>Promise()</code></a> constructor.</p>\n<p><code>then()</code> supports subclassing, which means it can be called on instances of subclasses of <code>Promise</code>, and the result will be a promise of the subclass type. You can customize the type of the return value through the <a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/Symbol.species\"><code>[Symbol.species]</code></a> property.</p>"}},{"type":"prose","value":{"id":"examples","title":"Examples","isH3":false,"content":""}},{"type":"prose","value":{"id":"using_the_then_method","title":"Using the then() method","isH3":true,"content":"<div class=\"code-example\"><div class=\"example-header\"><span class=\"language-name\">js</span></div><pre class=\"brush: js notranslate\"><code>const p1 = new Promise((resolve, reject) =&gt; {\n  resolve(\"Success!\");\n  // or\n  // reject(new Error(\"Error!\"));\n});\n\np1.then(\n  (value) =&gt; {\n    console.log(value); // Success!\n  },\n  (reason) =&gt; {\n    console.error(reason); // Error!\n  },\n);\n</code></pre></div>"}},{"type":"prose","value":{"id":"having_a_non-function_as_either_parameter","title":"Having a non-function as either parameter","isH3":true,"content":"<div class=\"code-example\"><div class=\"example-header\"><span class=\"language-name\">js</span></div><pre class=\"brush: js notranslate\"><code>Promise.resolve(1).then(2).then(console.log); // 1\nPromise.reject(1).then(2, 2).then(console.log, console.log); // 1\n</code></pre></div>"}},{"type":"prose","value":{"id":"chaining","title":"Chaining","isH3":true,"content":"<p>The <code>then</code> method returns a new <code>Promise</code>, which allows for method chaining.</p>\n<p>If the function passed as handler to <code>then</code> returns a <code>Promise</code>, an equivalent <code>Promise</code> will be exposed to the subsequent <code>then</code> in the method chain. The below snippet simulates asynchronous code with the <code>setTimeout</code> function.</p>\n<div class=\"code-example\"><div class=\"example-header\"><span class=\"language-name\">js</span></div><pre class=\"brush: js notranslate\"><code>Promise.resolve(\"foo\")\n  // 1. Receive \"foo\", concatenate \"bar\" to it, and resolve that to the next then\n  .then(\n    (string) =&gt;\n      new Promise((resolve, reject) =&gt; {\n        setTimeout(() =&gt; {\n          string += \"bar\";\n          resolve(string);\n        }, 1);\n      }),\n  )\n  // 2. receive \"foobar\", register a callback function to work on that string\n  // and print it to the console, but not before returning the unworked on\n  // string to the next then\n  .then((string) =&gt; {\n    setTimeout(() =&gt; {\n      string += \"baz\";\n      console.log(string); // foobarbaz\n    }, 1);\n    return string;\n  })\n  // 3. print helpful messages about how the code in this section will be run\n  // before the string is actually processed by the mocked asynchronous code in the\n  // previous then block.\n  .then((string) =&gt; {\n    console.log(\n      \"Last Then: oops... didn't bother to instantiate and return a promise in the prior then so the sequence may be a bit surprising\",\n    );\n\n    // Note that `string` will not have the 'baz' bit of it at this point. This\n    // is because we mocked that to happen asynchronously with a setTimeout function\n    console.log(string); // foobar\n  });\n\n// Logs, in order:\n// Last Then: oops... didn't bother to instantiate and return a promise in the prior then so the sequence may be a bit surprising\n// foobar\n// foobarbaz\n</code></pre></div>\n<p>The value returned from <code>then()</code> is resolved in the same way as <a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/resolve\"><code>Promise.resolve()</code></a>. This means <a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise#thenables\">thenable objects</a> are supported, and if the return value is not a promise, it's implicitly wrapped in a <code>Promise</code> and then resolved.</p>\n<div class=\"code-example\"><div class=\"example-header\"><span class=\"language-name\">js</span></div><pre class=\"brush: js notranslate\"><code>const p2 = new Promise((resolve, reject) =&gt; {\n  resolve(1);\n});\n\np2.then((value) =&gt; {\n  console.log(value); // 1\n  return value + 1;\n}).then((value) =&gt; {\n  console.log(value, \"- A synchronous value works\"); // 2 - A synchronous value works\n});\n\np2.then((value) =&gt; {\n  console.log(value); // 1\n});\n</code></pre></div>\n<p>A <code>then</code> call returns a promise that eventually rejects if the function throws an error or returns a rejected Promise.</p>\n<div class=\"code-example\"><div class=\"example-header\"><span class=\"language-name\">js</span></div><pre class=\"brush: js notranslate\"><code>Promise.resolve()\n  .then(() =&gt; {\n    // Makes .then() return a rejected promise\n    throw new Error(\"Oh no!\");\n  })\n  .then(\n    () =&gt; {\n      console.log(\"Not called.\");\n    },\n    (error) =&gt; {\n      console.error(`onRejected function called: ${error.message}`);\n    },\n  );\n</code></pre></div>\n<p>In practice, it is often desirable to <a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/catch\"><code>catch()</code></a> rejected promises rather than <code>then()</code>'s two-case syntax, as demonstrated below.</p>\n<div class=\"code-example\"><div class=\"example-header\"><span class=\"language-name\">js</span></div><pre class=\"brush: js notranslate\"><code>Promise.resolve()\n  .then(() =&gt; {\n    // Makes .then() return a rejected promise\n    throw new Error(\"Oh no!\");\n  })\n  .catch((error) =&gt; {\n    console.error(`onRejected function called: ${error.message}`);\n  })\n  .then(() =&gt; {\n    console.log(\"I am always called even if the prior then's promise rejects\");\n  });\n</code></pre></div>\n<p>In all other cases, the returned promise eventually fulfills. In the following example, the first <code>then()</code> returns <code>42</code> wrapped in a fulfilled Promise, even though the previous Promise in the chain was rejected.</p>\n<div class=\"code-example\"><div class=\"example-header\"><span class=\"language-name\">js</span></div><pre class=\"brush: js notranslate\"><code>Promise.reject()\n  .then(\n    () =&gt; 99,\n    () =&gt; 42,\n  ) // onRejected returns 42 which is wrapped in a fulfilled Promise\n  .then((solution) =&gt; console.log(`Resolved with ${solution}`)); // Fulfilled with 42\n</code></pre></div>\n<p>If <code>onFulfilled</code> returns a promise, the return value of <code>then</code> will be fulfilled/rejected based on the eventual state of that promise.</p>\n<div class=\"code-example\"><div class=\"example-header\"><span class=\"language-name\">js</span></div><pre class=\"brush: js notranslate\"><code>function resolveLater(resolve, reject) {\n  setTimeout(() =&gt; {\n    resolve(10);\n  }, 1000);\n}\nfunction rejectLater(resolve, reject) {\n  setTimeout(() =&gt; {\n    reject(new Error(\"Error\"));\n  }, 1000);\n}\n\nconst p1 = Promise.resolve(\"foo\");\nconst p2 = p1.then(() =&gt; {\n  // Return promise here, that will be resolved to 10 after 1 second\n  return new Promise(resolveLater);\n});\np2.then(\n  (v) =&gt; {\n    console.log(\"resolved\", v); // \"resolved\", 10\n  },\n  (e) =&gt; {\n    // not called\n    console.error(\"rejected\", e);\n  },\n);\n\nconst p3 = p1.then(() =&gt; {\n  // Return promise here, that will be rejected with 'Error' after 1 second\n  return new Promise(rejectLater);\n});\np3.then(\n  (v) =&gt; {\n    // not called\n    console.log(\"resolved\", v);\n  },\n  (e) =&gt; {\n    console.error(\"rejected\", e); // \"rejected\", 'Error'\n  },\n);\n</code></pre></div>\n<p>You can use chaining to implement one function with a Promise-based API on top of another such function.</p>\n<div class=\"code-example\"><div class=\"example-header\"><span class=\"language-name\">js</span></div><pre class=\"brush: js notranslate\"><code>function fetchCurrentData() {\n  // The fetch() API returns a Promise. This function\n  // exposes a similar API, except the fulfillment\n  // value of this function's Promise has had more\n  // work done on it.\n  return fetch(\"current-data.json\").then((response) =&gt; {\n    if (response.headers.get(\"content-type\") !== \"application/json\") {\n      throw new TypeError();\n    }\n    const j = response.json();\n    // maybe do something with j\n\n    // fulfillment value given to user of\n    // fetchCurrentData().then()\n    return j;\n  });\n}\n</code></pre></div>"}},{"type":"prose","value":{"id":"asynchronicity_of_then","title":"Asynchronicity of then()","isH3":true,"content":"<p>The following is an example to demonstrate the asynchronicity of the <code>then</code> method.</p>\n<div class=\"code-example\"><div class=\"example-header\"><span class=\"language-name\">js</span></div><pre class=\"brush: js notranslate\"><code>// Using a resolved promise 'resolvedProm' for example,\n// the function call 'resolvedProm.then(...)' returns a new promise immediately,\n// but its handler '(value) =&gt; {...}' will get called asynchronously as demonstrated by the console.logs.\n// the new promise is assigned to 'thenProm',\n// and thenProm will be resolved with the value returned by handler\nconst resolvedProm = Promise.resolve(33);\nconsole.log(resolvedProm);\n\nconst thenProm = resolvedProm.then((value) =&gt; {\n  console.log(\n    `this gets called after the end of the main stack. the value received is: ${value}, the value returned is: ${\n      value + 1\n    }`,\n  );\n  return value + 1;\n});\nconsole.log(thenProm);\n\n// Using setTimeout, we can postpone the execution of a function to the moment the stack is empty\nsetTimeout(() =&gt; {\n  console.log(thenProm);\n});\n\n// Logs, in order:\n// Promise {[[PromiseStatus]]: \"resolved\", [[PromiseResult]]: 33}\n// Promise {[[PromiseStatus]]: \"pending\", [[PromiseResult]]: undefined}\n// \"this gets called after the end of the main stack. the value received is: 33, the value returned is: 34\"\n// Promise {[[PromiseStatus]]: \"resolved\", [[PromiseResult]]: 34}\n</code></pre></div>"}},{"type":"specifications","value":{"id":"specifications","title":"Specifications","isH3":false,"specifications":[{"bcdSpecificationURL":"https://tc39.es/ecma262/multipage/control-abstraction-objects.html#sec-promise.prototype.then","title":"ECMAScript Language Specification"}],"query":"javascript.builtins.Promise.then"}},{"type":"browser_compatibility","value":{"id":"browser_compatibility","title":"Browser compatibility","isH3":false,"query":"javascript.builtins.Promise.then"}},{"type":"prose","value":{"id":"see_also","title":"See also","isH3":false,"content":"<ul>\n<li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise\"><code>Promise</code></a></li>\n<li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/catch\"><code>Promise.prototype.catch()</code></a></li>\n</ul>"}}],"isActive":true,"isMarkdown":true,"isTranslated":false,"locale":"en-US","mdn_url":"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then","modified":"2024-07-18T01:34:38.000Z","native":"English (US)","noIndexing":false,"other_translations":[{"locale":"de","title":"Promise.prototype.then()","native":"Deutsch"},{"locale":"es","title":"Promise.prototype.then()","native":"Español"},{"locale":"fr","title":"Promise.prototype.then()","native":"Français"},{"locale":"ja","title":"Promise.prototype.then()","native":"日本語"},{"locale":"ko","title":"Promise.prototype.then()","native":"한국어"},{"locale":"pt-BR","title":"Promise.prototype.then()","native":"Português (do Brasil)"},{"locale":"ru","title":"Promise.prototype.then()","native":"Русский"},{"locale":"zh-CN","title":"Promise.prototype.then()","native":"中文 (简体)"},{"locale":"zh-TW","title":"Promise.prototype.then()","native":"正體中文 (繁體)"}],"pageTitle":"Promise.prototype.then() - JavaScript | MDN","parents":[{"uri":"/en-US/docs/Web","title":"References"},{"uri":"/en-US/docs/Web/JavaScript","title":"JavaScript"},{"uri":"/en-US/docs/Web/JavaScript/Reference","title":"Reference"},{"uri":"/en-US/docs/Web/JavaScript/Reference/Global_Objects","title":"Standard built-in objects"},{"uri":"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise","title":"Promise"},{"uri":"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then","title":"Promise.prototype.then()"}],"popularity":null,"short_title":"Promise.prototype.then()","sidebarHTML":"<ol><li class=\"section\"><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects\">Standard built-in objects</a></li><li class=\"section\"><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise\"><code>Promise</code></a></li><li class=\"toggle\"><details open=\"\"><summary>Constructor</summary><ol><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/Promise\"><code>Promise() constructor</code></a></li></ol></details></li><li class=\"toggle\"><details open=\"\"><summary>Static methods</summary><ol><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all\"><code>Promise.all()</code></a></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/allSettled\"><code>Promise.allSettled()</code></a></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/any\"><code>Promise.any()</code></a></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/race\"><code>Promise.race()</code></a></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/reject\"><code>Promise.reject()</code></a></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/resolve\"><code>Promise.resolve()</code></a></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/try\"><code>Promise.try()</code></a></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/withResolvers\"><code>Promise.withResolvers()</code></a></li></ol></details></li><li class=\"toggle\"><details open=\"\"><summary>Static properties</summary><ol><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/Symbol.species\"><code>Promise[Symbol.species]</code></a></li></ol></details></li><li class=\"toggle\"><details open=\"\"><summary>Instance methods</summary><ol><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/catch\"><code>Promise.prototype.catch()</code></a></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/finally\"><code>Promise.prototype.finally()</code></a></li><li><em><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then\" aria-current=\"page\"><code>Promise.prototype.then()</code></a></em></li></ol></details></li><li class=\"section\">Inheritance</li><li class=\"section\"><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object\"><code>Object/Function</code></a></li><li class=\"toggle\"><details><summary>Static methods</summary><ol><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply\"><code>Function.prototype.apply()</code></a></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind\"><code>Function.prototype.bind()</code></a></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call\"><code>Function.prototype.call()</code></a></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/toString\"><code>Function.prototype.toString()</code></a></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/Symbol.hasInstance\"><code>Function.prototype[Symbol.hasInstance]()</code></a></li></ol></details></li><li class=\"toggle\"><details><summary>Static properties</summary><ol><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/displayName\"><code>Function: displayName</code></a><abbr class=\"icon icon-nonstandard\" title=\"Non-standard. Check cross-browser support before using.\">\n<span class=\"visually-hidden\">Non-standard</span>\n</abbr></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/length\"><code>Function: length</code></a></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name\"><code>Function: name</code></a></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/prototype\"><code>Function: prototype</code></a></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/arguments\"><code>Function.prototype.arguments</code></a><abbr class=\"icon icon-nonstandard\" title=\"Non-standard. Check cross-browser support before using.\">\n<span class=\"visually-hidden\">Non-standard</span>\n</abbr><abbr class=\"icon icon-deprecated\" title=\"Deprecated. Not for use in new websites.\">\n<span class=\"visually-hidden\">Deprecated</span>\n</abbr></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/caller\"><code>Function.prototype.caller</code></a><abbr class=\"icon icon-nonstandard\" title=\"Non-standard. Check cross-browser support before using.\">\n<span class=\"visually-hidden\">Non-standard</span>\n</abbr><abbr class=\"icon icon-deprecated\" title=\"Deprecated. Not for use in new websites.\">\n<span class=\"visually-hidden\">Deprecated</span>\n</abbr></li></ol></details></li><li class=\"toggle\"><details><summary>Instance methods</summary><ol><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/__defineGetter__\"><code>Object.prototype.__defineGetter__()</code></a><abbr class=\"icon icon-deprecated\" title=\"Deprecated. Not for use in new websites.\">\n<span class=\"visually-hidden\">Deprecated</span>\n</abbr></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/__defineSetter__\"><code>Object.prototype.__defineSetter__()</code></a><abbr class=\"icon icon-deprecated\" title=\"Deprecated. Not for use in new websites.\">\n<span class=\"visually-hidden\">Deprecated</span>\n</abbr></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/__lookupGetter__\"><code>Object.prototype.__lookupGetter__()</code></a><abbr class=\"icon icon-deprecated\" title=\"Deprecated. Not for use in new websites.\">\n<span class=\"visually-hidden\">Deprecated</span>\n</abbr></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/__lookupSetter__\"><code>Object.prototype.__lookupSetter__()</code></a><abbr class=\"icon icon-deprecated\" title=\"Deprecated. Not for use in new websites.\">\n<span class=\"visually-hidden\">Deprecated</span>\n</abbr></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty\"><code>Object.prototype.hasOwnProperty()</code></a></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isPrototypeOf\"><code>Object.prototype.isPrototypeOf()</code></a></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/propertyIsEnumerable\"><code>Object.prototype.propertyIsEnumerable()</code></a></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/toLocaleString\"><code>Object.prototype.toLocaleString()</code></a></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/toString\"><code>Object.prototype.toString()</code></a></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/valueOf\"><code>Object.prototype.valueOf()</code></a></li></ol></details></li><li class=\"toggle\"><details><summary>Instance properties</summary><ol><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/proto\"><code>Object.prototype.__proto__</code></a><abbr class=\"icon icon-deprecated\" title=\"Deprecated. Not for use in new websites.\">\n<span class=\"visually-hidden\">Deprecated</span>\n</abbr></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/constructor\"><code>Object.prototype.constructor</code></a></li></ol></details></li></ol>","source":{"folder":"en-us/web/javascript/reference/global_objects/promise/then","github_url":"https://github.com/mdn/content/blob/main/files/en-us/web/javascript/reference/global_objects/promise/then/index.md","last_commit_url":"https://github.com/mdn/content/commit/5c55770dc681e7855fe960cf6a725d4c7be4e95f","filename":"index.md"},"summary":"The then() method of Promise instances takes up to two arguments: callback functions for the fulfilled and rejected cases of the Promise. It stores the callbacks within the promise it is called on and immediately returns another Promise object, allowing you to chain calls to other promise methods.","title":"Promise.prototype.then()","toc":[{"text":"Try it","id":"try_it"},{"text":"Syntax","id":"syntax"},{"text":"Description","id":"description"},{"text":"Examples","id":"examples"},{"text":"Specifications","id":"specifications"},{"text":"Browser compatibility","id":"browser_compatibility"},{"text":"See also","id":"see_also"}],"baseline":{"baseline":"high","baseline_low_date":"2015-07-29","baseline_high_date":"2018-01-29","support":{"chrome":"32","chrome_android":"32","edge":"12","firefox":"29","firefox_android":"29","safari":"8","safari_ios":"8"}},"browserCompat":["javascript.builtins.Promise.then"],"pageType":"javascript-instance-method"}}</script>

</body><!-- Mirrored from developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 08 Jan 2025 13:10:18 GMT --></html>