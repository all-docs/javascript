<!DOCTYPE html><html lang="en-US" prefix="og: https://ogp.me/ns#"><!-- Mirrored from developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 08 Jan 2025 13:06:13 GMT --><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="icon" href="https://developer.mozilla.org/favicon-48x48.bc390275e955dacb2e65.png"><link rel="apple-touch-icon" href="https://developer.mozilla.org/apple-touch-icon.528534bba673c38049c2.png"><meta name="theme-color" content="#ffffff"><link rel="manifest" href="https://developer.mozilla.org/manifest.f42880861b394dd4dc9b.json"><link rel="search" type="application/opensearchdescription+xml" href="https://developer.mozilla.org/opensearch.xml" title="MDN Web Docs"><title>WeakMap - JavaScript | MDN</title><link rel="alternate" title="WeakMap" href="https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/WeakMap" hreflang="de"><link rel="alternate" title="WeakMap" href="https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/WeakMap" hreflang="es"><link rel="alternate" title="WeakMap" href="https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Global_Objects/WeakMap" hreflang="fr"><link rel="alternate" title="WeakMap" href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/WeakMap" hreflang="ja"><link rel="alternate" title="WeakMap" href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/WeakMap" hreflang="ko"><link rel="alternate" title="WeakMap" href="https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Reference/Global_Objects/WeakMap" hreflang="pt"><link rel="alternate" title="WeakMap" href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/WeakMap" hreflang="ru"><link rel="alternate" title="WeakMap" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/WeakMap" hreflang="zh"><link rel="alternate" title="WeakMap" href="WeakMap.html" hreflang="en"><link rel="preload" as="font" type="font/woff2" href="https://developer.mozilla.org/static/media/Inter.var.c2fe3cb2b7c746f7966a.woff2" crossorigin=""><link rel="alternate" type="application/rss+xml" title="MDN Blog RSS Feed" href="https://developer.mozilla.org/en-US/blog/rss.xml" hreflang="en"><meta name="description" content="A WeakMap is a collection of key/value pairs whose keys must be objects or non-registered symbols, with values of any arbitrary JavaScript type, and which does not create strong references to its keys. That is, an object's presence as a key in a WeakMap does not prevent the object from being garbage collected. Once an object used as a key has been collected, its corresponding values in any WeakMap become candidates for garbage collection as well — as long as they aren't strongly referred to elsewhere. The only primitive type that can be used as a WeakMap key is symbol — more specifically, non-registered symbols — because non-registered symbols are guaranteed to be unique and cannot be re-created."><meta property="og:url" content="WeakMap.html"><meta property="og:title" content="WeakMap - JavaScript | MDN"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:description" content="A WeakMap is a collection of key/value pairs whose keys must be objects or non-registered symbols, with values of any arbitrary JavaScript type, and which does not create strong references to its keys. That is, an object's presence as a key in a WeakMap does not prevent the object from being garbage collected. Once an object used as a key has been collected, its corresponding values in any WeakMap become candidates for garbage collection as well — as long as they aren't strongly referred to elsewhere. The only primitive type that can be used as a WeakMap key is symbol — more specifically, non-registered symbols — because non-registered symbols are guaranteed to be unique and cannot be re-created."><meta property="og:image" content="https://developer.mozilla.org/mdn-social-share.d893525a4fb5fb1f67a2.png"><meta property="og:image:type" content="image/png"><meta property="og:image:height" content="1080"><meta property="og:image:width" content="1920"><meta property="og:image:alt" content="The MDN Web Docs logo, featuring a blue accent color, displayed on a solid black background."><meta property="og:site_name" content="MDN Web Docs"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:creator" content="MozDevNet"><link rel="canonical" href="WeakMap.html"><style media="print">.article-actions-container,.document-toc-container,.language-menu,.main-menu-toggle,.on-github,.page-footer,.place,.sidebar,.top-banner,.top-navigation-main,ul.prev-next{display:none!important}.main-page-content,.main-page-content pre{padding:2px}.main-page-content pre{border-left-width:2px}</style><link href="https://developer.mozilla.org/static/css/main.65aa8eed.css" rel="stylesheet"></head><body><script>if(document.body.addEventListener("load",(t=>{t.target.classList.contains("interactive")&&t.target.setAttribute("data-readystate","complete")}),{capture:!0}),window&&document.documentElement){const t={light:"#ffffff",dark:"#1b1b1b"};try{const e=window.localStorage.getItem("theme");e&&(document.documentElement.className=e,document.documentElement.style.backgroundColor=t[e]);const o=window.localStorage.getItem("nop");o&&(document.documentElement.dataset.nop=o)}catch(t){console.warn("Unable to read theme from localStorage",t)}}</script><div id="root"><div class="page-wrapper  category-javascript document-page"><div class="main-wrapper"><main id="content" class="main-content  "><article class="main-page-content" lang="en-US"><header><h1>WeakMap</h1><details class="baseline-indicator high"><summary><span class="indicator" role="img" aria-label="Baseline Check"></span><h2>Baseline<!-- --> <span class="not-bold">Widely available</span></h2><div class="browsers"><span class="engine" title="Supported in Chrome and Edge"><span class="browser chrome supported" role="img" aria-label="Chrome check"></span><span class="browser edge supported" role="img" aria-label="Edge check"></span></span><span class="engine" title="Supported in Firefox"><span class="browser firefox supported" role="img" aria-label="Firefox check"></span></span><span class="engine" title="Supported in Safari"><span class="browser safari supported" role="img" aria-label="Safari check"></span></span></div><span class="icon icon-chevron "></span></summary><div class="extra"><p>This feature is well established and works across many devices and browser versions. It’s been available across browsers since<!-- --> <!-- -->July 2015<!-- -->.</p><ul><li><a href="https://developer.mozilla.org/en-US/docs/Glossary/Baseline/Compatibility" data-glean="baseline_link_learn_more" target="_blank" class="learn-more">Learn more</a></li><li><a href="#browser_compatibility" data-glean="baseline_link_bcd_table">See full compatibility</a></li><li><a href="https://survey.alchemer.com/s3/7634825/MDN-baseline-feedback?page=%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FWeakMap&amp;level=high" data-glean="baseline_link_feedback" class="feedback-link" target="_blank" rel="noreferrer">Report feedback</a></li></ul></div></details></header><div class="section-content"><p>A <strong><code>WeakMap</code></strong> is a collection of key/value pairs whose keys must be objects or <a href="Symbol.html#shared_symbols_in_the_global_symbol_registry">non-registered symbols</a>, with values of any arbitrary <a href="../../Data_structures.html">JavaScript type</a>, and which does not create strong references to its keys. That is, an object's presence as a key in a <code>WeakMap</code> does not prevent the object from being garbage collected. Once an object used as a key has been collected, its corresponding values in any <code>WeakMap</code> become candidates for garbage collection as well — as long as they aren't strongly referred to elsewhere. The only primitive type that can be used as a <code>WeakMap</code> key is symbol — more specifically, <a href="Symbol.html#shared_symbols_in_the_global_symbol_registry">non-registered symbols</a> — because non-registered symbols are guaranteed to be unique and cannot be re-created.</p>
<p><code>WeakMap</code> allows associating data to objects in a way that doesn't prevent the key objects from being collected, even if the values reference the keys. However, a <code>WeakMap</code> doesn't allow observing the liveness of its keys, which is why it doesn't allow enumeration; if a <code>WeakMap</code> exposed any method to obtain a list of its keys, the list would depend on the state of garbage collection, introducing non-determinism. If you want to have a list of keys, you should use a <a href="Map.html"><code>Map</code></a> rather than a <code>WeakMap</code>.</p>
<p>You can learn more about <code>WeakMap</code> in the <a href="../../Guide/Keyed_collections.html#weakmap_object">WeakMap object</a> section of the <a href="../../Guide/Keyed_collections.html">Keyed collections</a> guide.</p></div><section aria-labelledby="description"><h2 id="description"><a href="#description">Description</a></h2><div class="section-content"><p>Keys of WeakMaps must be garbage-collectable. Most <a href="https://developer.mozilla.org/en-US/docs/Glossary/Primitive">primitive data types</a> can be arbitrarily created and don't have a lifetime, so they cannot be used as keys. Objects and <a href="Symbol.html#shared_symbols_in_the_global_symbol_registry">non-registered symbols</a> can be used as keys because they are garbage-collectable.</p></div></section><section aria-labelledby="why_weakmap"><h3 id="why_weakmap"><a href="#why_weakmap">Why WeakMap?</a></h3><div class="section-content"><p>A map API <em>could</em> be implemented in JavaScript with two arrays (one for keys, one for values) shared by the four API methods. Setting elements on this map would involve pushing a key and value onto the end of each of those arrays simultaneously. As a result, the indices of the key and value would correspond to both arrays. Getting values from the map would involve iterating through all keys to find a match, then using the index of this match to retrieve the corresponding value from the array of values.</p>
<p>Such an implementation would have two main inconveniences:</p>
<ol>
<li>The first one is an <code>O(n)</code> set and search (<em>n</em> being the number of keys in the map) since both operations must iterate through the list of keys to find a matching value.</li>
<li>The second inconvenience is a memory leak because the arrays ensure that references to each key and each value are maintained indefinitely. These references prevent the keys from being garbage collected, even if there are no other references to the object. This would also prevent the corresponding values from being garbage collected.</li>
</ol>
<p>By contrast, in a <code>WeakMap</code>, a key object refers strongly to its contents as long as the key is not garbage collected, but weakly from then on. As such, a <code>WeakMap</code>:</p>
<ul>
<li>does not prevent garbage collection, which eventually removes references to the key object</li>
<li>allows garbage collection of any values if their key objects are not referenced from somewhere other than a <code>WeakMap</code></li>
</ul>
<p>A <code>WeakMap</code> can be a particularly useful construct when mapping keys to information about the key that is valuable <em>only if</em> the key has not been garbage collected.</p>
<p>But because a <code>WeakMap</code> doesn't allow observing the liveness of its keys, its keys are not enumerable. There is no method to obtain a list of the keys. If there were, the list would depend on the state of garbage collection, introducing non-determinism. If you want to have a list of keys, you should use a <a href="Map.html"><code>Map</code></a>.</p></div></section><section aria-labelledby="constructor"><h2 id="constructor"><a href="#constructor">Constructor</a></h2><div class="section-content"><dl>
<dt id="weakmap"><a href="WeakMap/WeakMap.html"><code>WeakMap()</code></a></dt>
<dd>
<p>Creates a new <code>WeakMap</code> object.</p>
</dd>
</dl></div></section><section aria-labelledby="instance_properties"><h2 id="instance_properties"><a href="#instance_properties">Instance properties</a></h2><div class="section-content"><p>These properties are defined on <code>WeakMap.prototype</code> and shared by all <code>WeakMap</code> instances.</p>
<dl>
<dt id="weakmap.prototype.constructor"><a href="Object/constructor.html"><code>WeakMap.prototype.constructor</code></a></dt>
<dd>
<p>The constructor function that created the instance object. For <code>WeakMap</code> instances, the initial value is the <a href="WeakMap/WeakMap.html"><code>WeakMap</code></a> constructor.</p>
</dd>
<dt id="weakmap.prototypesymbol.tostringtag"><a href="#weakmap.prototypesymbol.tostringtag"><code>WeakMap.prototype[Symbol.toStringTag]</code></a></dt>
<dd>
<p>The initial value of the <a href="Symbol/toStringTag.html"><code>[Symbol.toStringTag]</code></a> property is the string <code>"WeakMap"</code>. This property is used in <a href="Object/toString.html"><code>Object.prototype.toString()</code></a>.</p>
</dd>
</dl></div></section><section aria-labelledby="instance_methods"><h2 id="instance_methods"><a href="#instance_methods">Instance methods</a></h2><div class="section-content"><dl>
<dt id="weakmap.prototype.delete"><a href="WeakMap/delete.html"><code>WeakMap.prototype.delete()</code></a></dt>
<dd>
<p>Removes any value associated to the <code>key</code>. <code>WeakMap.prototype.has(key)</code> will return <code>false</code> afterwards.</p>
</dd>
<dt id="weakmap.prototype.get"><a href="WeakMap/get.html"><code>WeakMap.prototype.get()</code></a></dt>
<dd>
<p>Returns the value associated to the <code>key</code>, or <code>undefined</code> if there is none.</p>
</dd>
<dt id="weakmap.prototype.has"><a href="WeakMap/has.html"><code>WeakMap.prototype.has()</code></a></dt>
<dd>
<p>Returns a Boolean asserting whether a value has been associated to the <code>key</code> in the <code>WeakMap</code> object or not.</p>
</dd>
<dt id="weakmap.prototype.set"><a href="WeakMap/set.html"><code>WeakMap.prototype.set()</code></a></dt>
<dd>
<p>Sets the <code>value</code> for the <code>key</code> in the <code>WeakMap</code> object. Returns the <code>WeakMap</code> object.</p>
</dd>
</dl></div></section><section aria-labelledby="examples"><h2 id="examples"><a href="#examples">Examples</a></h2><div class="section-content"></div></section><section aria-labelledby="using_weakmap"><h3 id="using_weakmap"><a href="#using_weakmap">Using WeakMap</a></h3><div class="section-content"><div class="code-example"><div class="example-header"><span class="language-name">js</span></div><pre class="brush: js notranslate"><code>const wm1 = new WeakMap();
const wm2 = new WeakMap();
const wm3 = new WeakMap();
const o1 = {};
const o2 = function () {};
const o3 = window;

wm1.set(o1, 37);
wm1.set(o2, "azerty");
wm2.set(o1, o2); // a value can be anything, including an object or a function
wm2.set(o2, undefined);
wm2.set(wm1, wm2); // keys and values can be any objects. Even WeakMaps!

wm1.get(o2); // "azerty"
wm2.get(o2); // undefined, because that is the set value
wm2.get(o3); // undefined, because there is no key for o3 on wm2

wm1.has(o2); // true
wm2.has(o2); // true (even if the value itself is 'undefined')
wm2.has(o3); // false

wm3.set(o1, 37);
wm3.get(o1); // 37

wm1.has(o1); // true
wm1.delete(o1);
wm1.has(o1); // false
</code></pre></div></div></section><section aria-labelledby="implementing_a_weakmap-like_class_with_a_.clear_method"><h3 id="implementing_a_weakmap-like_class_with_a_.clear_method"><a href="#implementing_a_weakmap-like_class_with_a_.clear_method">Implementing a WeakMap-like class with a .clear() method</a></h3><div class="section-content"><div class="code-example"><div class="example-header"><span class="language-name">js</span></div><pre class="brush: js notranslate"><code>class ClearableWeakMap {
  #wm;
  constructor(init) {
    this.#wm = new WeakMap(init);
  }
  clear() {
    this.#wm = new WeakMap();
  }
  delete(k) {
    return this.#wm.delete(k);
  }
  get(k) {
    return this.#wm.get(k);
  }
  has(k) {
    return this.#wm.has(k);
  }
  set(k, v) {
    this.#wm.set(k, v);
    return this;
  }
}
</code></pre></div></div></section><section aria-labelledby="emulating_private_members"><h3 id="emulating_private_members"><a href="#emulating_private_members">Emulating private members</a></h3><div class="section-content"><p>Developers can use a <code>WeakMap</code> to associate private data to an object, with the following benefits:</p>
<ul>
<li>Compared to a <a href="Map.html"><code>Map</code></a>, a WeakMap does not hold strong references to the object used as the key, so the metadata shares the same lifetime as the object itself, avoiding memory leaks.</li>
<li>Compared to using non-enumerable and/or <a href="Symbol.html"><code>Symbol</code></a> properties, a WeakMap is external to the object and there is no way for user code to retrieve the metadata through reflective methods like <a href="Object/getOwnPropertySymbols.html"><code>Object.getOwnPropertySymbols</code></a>.</li>
<li>Compared to a <a href="../../Closures.html">closure</a>, the same WeakMap can be reused for all instances created from a constructor, making it more memory-efficient, and allows different instances of the same class to read the private members of each other.</li>
</ul>
<div class="code-example"><div class="example-header"><span class="language-name">js</span></div><pre class="brush: js notranslate"><code>let Thing;

{
  const privateScope = new WeakMap();
  let counter = 0;

  Thing = function () {
    this.someProperty = "foo";

    privateScope.set(this, {
      hidden: ++counter,
    });
  };

  Thing.prototype.showPublic = function () {
    return this.someProperty;
  };

  Thing.prototype.showPrivate = function () {
    return privateScope.get(this).hidden;
  };
}

console.log(typeof privateScope);
// "undefined"

const thing = new Thing();

console.log(thing);
// Thing {someProperty: "foo"}

thing.showPublic();
// "foo"

thing.showPrivate();
// 1
</code></pre></div>
<p>This is roughly equivalent to the following, using <a href="../Classes/Private_properties.html">private fields</a>:</p>
<div class="code-example"><div class="example-header"><span class="language-name">js</span></div><pre class="brush: js notranslate"><code>class Thing {
  static #counter = 0;
  #hidden;
  constructor() {
    this.someProperty = "foo";
    this.#hidden = ++Thing.#counter;
  }
  showPublic() {
    return this.someProperty;
  }
  showPrivate() {
    return this.#hidden;
  }
}

console.log(thing);
// Thing {someProperty: "foo"}

thing.showPublic();
// "foo"

thing.showPrivate();
// 1
</code></pre></div></div></section><section aria-labelledby="associating_metadata"><h3 id="associating_metadata"><a href="#associating_metadata">Associating metadata</a></h3><div class="section-content"><p>A <code>WeakMap</code> can be used to associate metadata with an object, without affecting the lifetime of the object itself. This is very similar to the private members example, since private members are also modelled as external metadata that doesn't participate in <a href="../../Inheritance_and_the_prototype_chain.html">prototypical inheritance</a>.</p>
<p>This use case can be extended to already-created objects. For example, on the web, we may want to associate extra data with a DOM element, which the DOM element may access later. A common approach is to attach the data as a property:</p>
<div class="code-example"><div class="example-header"><span class="language-name">js</span></div><pre class="brush: js notranslate"><code>const buttons = document.querySelectorAll(".button");
buttons.forEach((button) =&gt; {
  button.clicked = false;
  button.addEventListener("click", () =&gt; {
    button.clicked = true;
    const currentButtons = [...document.querySelectorAll(".button")];
    if (currentButtons.every((button) =&gt; button.clicked)) {
      console.log("All buttons have been clicked!");
    }
  });
});
</code></pre></div>
<p>This approach works, but it has a few pitfalls:</p>
<ul>
<li>The <code>clicked</code> property is enumerable, so it will show up in <a href="Object/keys.html"><code>Object.keys(button)</code></a>, <a href="../Statements/for...html"><code>for...in</code></a> loops, etc. This can be mitigated by using <a href="Object/defineProperty.html"><code>Object.defineProperty()</code></a>, but that makes the code more verbose.</li>
<li>The <code>clicked</code> property is a normal string property, so it can be accessed and overwritten by other code. This can be mitigated by using a <a href="Symbol.html"><code>Symbol</code></a> key, but the key would still be accessible via <a href="Object/getOwnPropertySymbols.html"><code>Object.getOwnPropertySymbols()</code></a>.</li>
</ul>
<p>Using a <code>WeakMap</code> fixes these:</p>
<div class="code-example"><div class="example-header"><span class="language-name">js</span></div><pre class="brush: js notranslate"><code>const buttons = document.querySelectorAll(".button");
const clicked = new WeakMap();
buttons.forEach((button) =&gt; {
  clicked.set(button, false);
  button.addEventListener("click", () =&gt; {
    clicked.set(button, true);
    const currentButtons = [...document.querySelectorAll(".button")];
    if (currentButtons.every((button) =&gt; clicked.get(button))) {
      console.log("All buttons have been clicked!");
    }
  });
});
</code></pre></div>
<p>Here, only code that has access to <code>clicked</code> knows the clicked state of each button, and external code can't modify the states. In addition, if any of the buttons gets removed from the DOM, the associated metadata will automatically get garbage-collected.</p></div></section><section aria-labelledby="caching"><h3 id="caching"><a href="#caching">Caching</a></h3><div class="section-content"><p>You can associate objects passed to a function with the result of the function, so that if the same object is passed again, the cached result can be returned without re-executing the function. This is useful if the function is pure (i.e. it doesn't mutate any outside objects or cause other observable side effects).</p>
<div class="code-example"><div class="example-header"><span class="language-name">js</span></div><pre class="brush: js notranslate"><code>const cache = new WeakMap();
function handleObjectValues(obj) {
  if (cache.has(obj)) {
    return cache.get(obj);
  }
  const result = Object.values(obj).map(heavyComputation);
  cache.set(obj, result);
  return result;
}
</code></pre></div>
<p>This only works if your function's input is an object. Moreover, even if the input is never passed in again, the result still remains forever in the cache as long as the key (input) is alive. A more effective way is to use a <a href="Map.html"><code>Map</code></a> paired with <a href="WeakRef.html"><code>WeakRef</code></a> objects, which allows you to associate any type of input value with its respective (potentially large) computation result. See the <a href="../../Memory_management.html#weakrefs_and_finalizationregistry">WeakRefs and FinalizationRegistry</a> example for more details.</p></div></section><h2 id="specifications"><a href="#specifications">Specifications</a></h2><table class="standard-table"><thead><tr><th scope="col">Specification</th></tr></thead><tbody><tr><td><a href="https://tc39.es/ecma262/multipage/keyed-collections.html#sec-weakmap-objects">ECMAScript Language Specification<!-- --> <br><small># <!-- -->sec-weakmap-objects</small></a></td></tr></tbody></table><h2 id="browser_compatibility"><a href="#browser_compatibility">Browser compatibility</a></h2><p>BCD tables only load in the browser<noscript> <!-- -->with JavaScript enabled. Enable JavaScript to view data.</noscript></p><section aria-labelledby="see_also"><h2 id="see_also"><a href="#see_also">See also</a></h2><div class="section-content"><ul>
<li><a href="https://github.com/zloirock/core-js#weakmap" class="external" target="_blank">Polyfill of <code>WeakMap</code> in <code>core-js</code></a></li>
<li><a href="../../Guide/Keyed_collections.html#weakmap_object">Keyed collections</a></li>
<li><a href="https://fitzgen.com/2014/01/13/hiding-implementation-details-with-e6-weakmaps.html" class="external" target="_blank">Hiding Implementation Details with ECMAScript 6 WeakMaps</a> by Nick Fitzgerald (2014)</li>
<li><a href="Map.html"><code>Map</code></a></li>
<li><a href="Set.html"><code>Set</code></a></li>
<li><a href="WeakSet.html"><code>WeakSet</code></a></li>
</ul></div></section></article></main></div></div></div><script type="application/json" id="hydration">{"url":"/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap","doc":{"body":[{"type":"prose","value":{"id":null,"title":null,"isH3":false,"content":"<p>A <strong><code>WeakMap</code></strong> is a collection of key/value pairs whose keys must be objects or <a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol#shared_symbols_in_the_global_symbol_registry\">non-registered symbols</a>, with values of any arbitrary <a href=\"/en-US/docs/Web/JavaScript/Data_structures\">JavaScript type</a>, and which does not create strong references to its keys. That is, an object's presence as a key in a <code>WeakMap</code> does not prevent the object from being garbage collected. Once an object used as a key has been collected, its corresponding values in any <code>WeakMap</code> become candidates for garbage collection as well — as long as they aren't strongly referred to elsewhere. The only primitive type that can be used as a <code>WeakMap</code> key is symbol — more specifically, <a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol#shared_symbols_in_the_global_symbol_registry\">non-registered symbols</a> — because non-registered symbols are guaranteed to be unique and cannot be re-created.</p>\n<p><code>WeakMap</code> allows associating data to objects in a way that doesn't prevent the key objects from being collected, even if the values reference the keys. However, a <code>WeakMap</code> doesn't allow observing the liveness of its keys, which is why it doesn't allow enumeration; if a <code>WeakMap</code> exposed any method to obtain a list of its keys, the list would depend on the state of garbage collection, introducing non-determinism. If you want to have a list of keys, you should use a <a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map\"><code>Map</code></a> rather than a <code>WeakMap</code>.</p>\n<p>You can learn more about <code>WeakMap</code> in the <a href=\"/en-US/docs/Web/JavaScript/Guide/Keyed_collections#weakmap_object\">WeakMap object</a> section of the <a href=\"/en-US/docs/Web/JavaScript/Guide/Keyed_collections\">Keyed collections</a> guide.</p>"}},{"type":"prose","value":{"id":"description","title":"Description","isH3":false,"content":"<p>Keys of WeakMaps must be garbage-collectable. Most <a href=\"/en-US/docs/Glossary/Primitive\">primitive data types</a> can be arbitrarily created and don't have a lifetime, so they cannot be used as keys. Objects and <a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol#shared_symbols_in_the_global_symbol_registry\">non-registered symbols</a> can be used as keys because they are garbage-collectable.</p>"}},{"type":"prose","value":{"id":"why_weakmap","title":"Why WeakMap?","isH3":true,"content":"<p>A map API <em>could</em> be implemented in JavaScript with two arrays (one for keys, one for values) shared by the four API methods. Setting elements on this map would involve pushing a key and value onto the end of each of those arrays simultaneously. As a result, the indices of the key and value would correspond to both arrays. Getting values from the map would involve iterating through all keys to find a match, then using the index of this match to retrieve the corresponding value from the array of values.</p>\n<p>Such an implementation would have two main inconveniences:</p>\n<ol>\n<li>The first one is an <code>O(n)</code> set and search (<em>n</em> being the number of keys in the map) since both operations must iterate through the list of keys to find a matching value.</li>\n<li>The second inconvenience is a memory leak because the arrays ensure that references to each key and each value are maintained indefinitely. These references prevent the keys from being garbage collected, even if there are no other references to the object. This would also prevent the corresponding values from being garbage collected.</li>\n</ol>\n<p>By contrast, in a <code>WeakMap</code>, a key object refers strongly to its contents as long as the key is not garbage collected, but weakly from then on. As such, a <code>WeakMap</code>:</p>\n<ul>\n<li>does not prevent garbage collection, which eventually removes references to the key object</li>\n<li>allows garbage collection of any values if their key objects are not referenced from somewhere other than a <code>WeakMap</code></li>\n</ul>\n<p>A <code>WeakMap</code> can be a particularly useful construct when mapping keys to information about the key that is valuable <em>only if</em> the key has not been garbage collected.</p>\n<p>But because a <code>WeakMap</code> doesn't allow observing the liveness of its keys, its keys are not enumerable. There is no method to obtain a list of the keys. If there were, the list would depend on the state of garbage collection, introducing non-determinism. If you want to have a list of keys, you should use a <a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map\"><code>Map</code></a>.</p>"}},{"type":"prose","value":{"id":"constructor","title":"Constructor","isH3":false,"content":"<dl>\n<dt id=\"weakmap\"><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap/WeakMap\"><code>WeakMap()</code></a></dt>\n<dd>\n<p>Creates a new <code>WeakMap</code> object.</p>\n</dd>\n</dl>"}},{"type":"prose","value":{"id":"instance_properties","title":"Instance properties","isH3":false,"content":"<p>These properties are defined on <code>WeakMap.prototype</code> and shared by all <code>WeakMap</code> instances.</p>\n<dl>\n<dt id=\"weakmap.prototype.constructor\"><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/constructor\"><code>WeakMap.prototype.constructor</code></a></dt>\n<dd>\n<p>The constructor function that created the instance object. For <code>WeakMap</code> instances, the initial value is the <a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap/WeakMap\"><code>WeakMap</code></a> constructor.</p>\n</dd>\n<dt id=\"weakmap.prototypesymbol.tostringtag\"><a href=\"#weakmap.prototypesymbol.tostringtag\"><code>WeakMap.prototype[Symbol.toStringTag]</code></a></dt>\n<dd>\n<p>The initial value of the <a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/toStringTag\"><code>[Symbol.toStringTag]</code></a> property is the string <code>\"WeakMap\"</code>. This property is used in <a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/toString\"><code>Object.prototype.toString()</code></a>.</p>\n</dd>\n</dl>"}},{"type":"prose","value":{"id":"instance_methods","title":"Instance methods","isH3":false,"content":"<dl>\n<dt id=\"weakmap.prototype.delete\"><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap/delete\"><code>WeakMap.prototype.delete()</code></a></dt>\n<dd>\n<p>Removes any value associated to the <code>key</code>. <code>WeakMap.prototype.has(key)</code> will return <code>false</code> afterwards.</p>\n</dd>\n<dt id=\"weakmap.prototype.get\"><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap/get\"><code>WeakMap.prototype.get()</code></a></dt>\n<dd>\n<p>Returns the value associated to the <code>key</code>, or <code>undefined</code> if there is none.</p>\n</dd>\n<dt id=\"weakmap.prototype.has\"><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap/has\"><code>WeakMap.prototype.has()</code></a></dt>\n<dd>\n<p>Returns a Boolean asserting whether a value has been associated to the <code>key</code> in the <code>WeakMap</code> object or not.</p>\n</dd>\n<dt id=\"weakmap.prototype.set\"><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap/set\"><code>WeakMap.prototype.set()</code></a></dt>\n<dd>\n<p>Sets the <code>value</code> for the <code>key</code> in the <code>WeakMap</code> object. Returns the <code>WeakMap</code> object.</p>\n</dd>\n</dl>"}},{"type":"prose","value":{"id":"examples","title":"Examples","isH3":false,"content":""}},{"type":"prose","value":{"id":"using_weakmap","title":"Using WeakMap","isH3":true,"content":"<div class=\"code-example\"><div class=\"example-header\"><span class=\"language-name\">js</span></div><pre class=\"brush: js notranslate\"><code>const wm1 = new WeakMap();\nconst wm2 = new WeakMap();\nconst wm3 = new WeakMap();\nconst o1 = {};\nconst o2 = function () {};\nconst o3 = window;\n\nwm1.set(o1, 37);\nwm1.set(o2, \"azerty\");\nwm2.set(o1, o2); // a value can be anything, including an object or a function\nwm2.set(o2, undefined);\nwm2.set(wm1, wm2); // keys and values can be any objects. Even WeakMaps!\n\nwm1.get(o2); // \"azerty\"\nwm2.get(o2); // undefined, because that is the set value\nwm2.get(o3); // undefined, because there is no key for o3 on wm2\n\nwm1.has(o2); // true\nwm2.has(o2); // true (even if the value itself is 'undefined')\nwm2.has(o3); // false\n\nwm3.set(o1, 37);\nwm3.get(o1); // 37\n\nwm1.has(o1); // true\nwm1.delete(o1);\nwm1.has(o1); // false\n</code></pre></div>"}},{"type":"prose","value":{"id":"implementing_a_weakmap-like_class_with_a_.clear_method","title":"Implementing a WeakMap-like class with a .clear() method","isH3":true,"content":"<div class=\"code-example\"><div class=\"example-header\"><span class=\"language-name\">js</span></div><pre class=\"brush: js notranslate\"><code>class ClearableWeakMap {\n  #wm;\n  constructor(init) {\n    this.#wm = new WeakMap(init);\n  }\n  clear() {\n    this.#wm = new WeakMap();\n  }\n  delete(k) {\n    return this.#wm.delete(k);\n  }\n  get(k) {\n    return this.#wm.get(k);\n  }\n  has(k) {\n    return this.#wm.has(k);\n  }\n  set(k, v) {\n    this.#wm.set(k, v);\n    return this;\n  }\n}\n</code></pre></div>"}},{"type":"prose","value":{"id":"emulating_private_members","title":"Emulating private members","isH3":true,"content":"<p>Developers can use a <code>WeakMap</code> to associate private data to an object, with the following benefits:</p>\n<ul>\n<li>Compared to a <a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map\"><code>Map</code></a>, a WeakMap does not hold strong references to the object used as the key, so the metadata shares the same lifetime as the object itself, avoiding memory leaks.</li>\n<li>Compared to using non-enumerable and/or <a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol\"><code>Symbol</code></a> properties, a WeakMap is external to the object and there is no way for user code to retrieve the metadata through reflective methods like <a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols\"><code>Object.getOwnPropertySymbols</code></a>.</li>\n<li>Compared to a <a href=\"/en-US/docs/Web/JavaScript/Closures\">closure</a>, the same WeakMap can be reused for all instances created from a constructor, making it more memory-efficient, and allows different instances of the same class to read the private members of each other.</li>\n</ul>\n<div class=\"code-example\"><div class=\"example-header\"><span class=\"language-name\">js</span></div><pre class=\"brush: js notranslate\"><code>let Thing;\n\n{\n  const privateScope = new WeakMap();\n  let counter = 0;\n\n  Thing = function () {\n    this.someProperty = \"foo\";\n\n    privateScope.set(this, {\n      hidden: ++counter,\n    });\n  };\n\n  Thing.prototype.showPublic = function () {\n    return this.someProperty;\n  };\n\n  Thing.prototype.showPrivate = function () {\n    return privateScope.get(this).hidden;\n  };\n}\n\nconsole.log(typeof privateScope);\n// \"undefined\"\n\nconst thing = new Thing();\n\nconsole.log(thing);\n// Thing {someProperty: \"foo\"}\n\nthing.showPublic();\n// \"foo\"\n\nthing.showPrivate();\n// 1\n</code></pre></div>\n<p>This is roughly equivalent to the following, using <a href=\"/en-US/docs/Web/JavaScript/Reference/Classes/Private_properties\">private fields</a>:</p>\n<div class=\"code-example\"><div class=\"example-header\"><span class=\"language-name\">js</span></div><pre class=\"brush: js notranslate\"><code>class Thing {\n  static #counter = 0;\n  #hidden;\n  constructor() {\n    this.someProperty = \"foo\";\n    this.#hidden = ++Thing.#counter;\n  }\n  showPublic() {\n    return this.someProperty;\n  }\n  showPrivate() {\n    return this.#hidden;\n  }\n}\n\nconsole.log(thing);\n// Thing {someProperty: \"foo\"}\n\nthing.showPublic();\n// \"foo\"\n\nthing.showPrivate();\n// 1\n</code></pre></div>"}},{"type":"prose","value":{"id":"associating_metadata","title":"Associating metadata","isH3":true,"content":"<p>A <code>WeakMap</code> can be used to associate metadata with an object, without affecting the lifetime of the object itself. This is very similar to the private members example, since private members are also modelled as external metadata that doesn't participate in <a href=\"/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain\">prototypical inheritance</a>.</p>\n<p>This use case can be extended to already-created objects. For example, on the web, we may want to associate extra data with a DOM element, which the DOM element may access later. A common approach is to attach the data as a property:</p>\n<div class=\"code-example\"><div class=\"example-header\"><span class=\"language-name\">js</span></div><pre class=\"brush: js notranslate\"><code>const buttons = document.querySelectorAll(\".button\");\nbuttons.forEach((button) =&gt; {\n  button.clicked = false;\n  button.addEventListener(\"click\", () =&gt; {\n    button.clicked = true;\n    const currentButtons = [...document.querySelectorAll(\".button\")];\n    if (currentButtons.every((button) =&gt; button.clicked)) {\n      console.log(\"All buttons have been clicked!\");\n    }\n  });\n});\n</code></pre></div>\n<p>This approach works, but it has a few pitfalls:</p>\n<ul>\n<li>The <code>clicked</code> property is enumerable, so it will show up in <a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys\"><code>Object.keys(button)</code></a>, <a href=\"/en-US/docs/Web/JavaScript/Reference/Statements/for...in\"><code>for...in</code></a> loops, etc. This can be mitigated by using <a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty\"><code>Object.defineProperty()</code></a>, but that makes the code more verbose.</li>\n<li>The <code>clicked</code> property is a normal string property, so it can be accessed and overwritten by other code. This can be mitigated by using a <a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol\"><code>Symbol</code></a> key, but the key would still be accessible via <a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols\"><code>Object.getOwnPropertySymbols()</code></a>.</li>\n</ul>\n<p>Using a <code>WeakMap</code> fixes these:</p>\n<div class=\"code-example\"><div class=\"example-header\"><span class=\"language-name\">js</span></div><pre class=\"brush: js notranslate\"><code>const buttons = document.querySelectorAll(\".button\");\nconst clicked = new WeakMap();\nbuttons.forEach((button) =&gt; {\n  clicked.set(button, false);\n  button.addEventListener(\"click\", () =&gt; {\n    clicked.set(button, true);\n    const currentButtons = [...document.querySelectorAll(\".button\")];\n    if (currentButtons.every((button) =&gt; clicked.get(button))) {\n      console.log(\"All buttons have been clicked!\");\n    }\n  });\n});\n</code></pre></div>\n<p>Here, only code that has access to <code>clicked</code> knows the clicked state of each button, and external code can't modify the states. In addition, if any of the buttons gets removed from the DOM, the associated metadata will automatically get garbage-collected.</p>"}},{"type":"prose","value":{"id":"caching","title":"Caching","isH3":true,"content":"<p>You can associate objects passed to a function with the result of the function, so that if the same object is passed again, the cached result can be returned without re-executing the function. This is useful if the function is pure (i.e. it doesn't mutate any outside objects or cause other observable side effects).</p>\n<div class=\"code-example\"><div class=\"example-header\"><span class=\"language-name\">js</span></div><pre class=\"brush: js notranslate\"><code>const cache = new WeakMap();\nfunction handleObjectValues(obj) {\n  if (cache.has(obj)) {\n    return cache.get(obj);\n  }\n  const result = Object.values(obj).map(heavyComputation);\n  cache.set(obj, result);\n  return result;\n}\n</code></pre></div>\n<p>This only works if your function's input is an object. Moreover, even if the input is never passed in again, the result still remains forever in the cache as long as the key (input) is alive. A more effective way is to use a <a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map\"><code>Map</code></a> paired with <a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakRef\"><code>WeakRef</code></a> objects, which allows you to associate any type of input value with its respective (potentially large) computation result. See the <a href=\"/en-US/docs/Web/JavaScript/Memory_management#weakrefs_and_finalizationregistry\">WeakRefs and FinalizationRegistry</a> example for more details.</p>"}},{"type":"specifications","value":{"id":"specifications","title":"Specifications","isH3":false,"specifications":[{"bcdSpecificationURL":"https://tc39.es/ecma262/multipage/keyed-collections.html#sec-weakmap-objects","title":"ECMAScript Language Specification"}],"query":"javascript.builtins.WeakMap"}},{"type":"browser_compatibility","value":{"id":"browser_compatibility","title":"Browser compatibility","isH3":false,"query":"javascript.builtins.WeakMap"}},{"type":"prose","value":{"id":"see_also","title":"See also","isH3":false,"content":"<ul>\n<li><a href=\"https://github.com/zloirock/core-js#weakmap\" class=\"external\" target=\"_blank\">Polyfill of <code>WeakMap</code> in <code>core-js</code></a></li>\n<li><a href=\"/en-US/docs/Web/JavaScript/Guide/Keyed_collections#weakmap_object\">Keyed collections</a></li>\n<li><a href=\"https://fitzgen.com/2014/01/13/hiding-implementation-details-with-e6-weakmaps.html\" class=\"external\" target=\"_blank\">Hiding Implementation Details with ECMAScript 6 WeakMaps</a> by Nick Fitzgerald (2014)</li>\n<li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map\"><code>Map</code></a></li>\n<li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set\"><code>Set</code></a></li>\n<li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakSet\"><code>WeakSet</code></a></li>\n</ul>"}}],"isActive":true,"isMarkdown":true,"isTranslated":false,"locale":"en-US","mdn_url":"/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap","modified":"2024-09-16T12:21:24.000Z","native":"English (US)","noIndexing":false,"other_translations":[{"locale":"de","title":"WeakMap","native":"Deutsch"},{"locale":"es","title":"WeakMap","native":"Español"},{"locale":"fr","title":"WeakMap","native":"Français"},{"locale":"ja","title":"WeakMap","native":"日本語"},{"locale":"ko","title":"WeakMap","native":"한국어"},{"locale":"pt-BR","title":"WeakMap","native":"Português (do Brasil)"},{"locale":"ru","title":"WeakMap","native":"Русский"},{"locale":"zh-CN","title":"WeakMap","native":"中文 (简体)"}],"pageTitle":"WeakMap - JavaScript | MDN","parents":[{"uri":"/en-US/docs/Web","title":"References"},{"uri":"/en-US/docs/Web/JavaScript","title":"JavaScript"},{"uri":"/en-US/docs/Web/JavaScript/Reference","title":"Reference"},{"uri":"/en-US/docs/Web/JavaScript/Reference/Global_Objects","title":"Standard built-in objects"},{"uri":"/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap","title":"WeakMap"}],"popularity":null,"short_title":"WeakMap","sidebarHTML":"<ol><li class=\"section\"><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects\">Standard built-in objects</a></li><li class=\"section\"><em><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap\" aria-current=\"page\"><code>WeakMap</code></a></em></li><li class=\"toggle\"><details open=\"\"><summary>Constructor</summary><ol><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap/WeakMap\"><code>WeakMap() constructor</code></a></li></ol></details></li><li class=\"toggle\"><details open=\"\"><summary>Instance methods</summary><ol><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap/delete\"><code>WeakMap.prototype.delete()</code></a></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap/get\"><code>WeakMap.prototype.get()</code></a></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap/has\"><code>WeakMap.prototype.has()</code></a></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap/set\"><code>WeakMap.prototype.set()</code></a></li></ol></details></li><li class=\"section\">Inheritance</li><li class=\"section\"><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object\"><code>Object/Function</code></a></li><li class=\"toggle\"><details><summary>Static methods</summary><ol><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply\"><code>Function.prototype.apply()</code></a></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind\"><code>Function.prototype.bind()</code></a></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call\"><code>Function.prototype.call()</code></a></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/toString\"><code>Function.prototype.toString()</code></a></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/Symbol.hasInstance\"><code>Function.prototype[Symbol.hasInstance]()</code></a></li></ol></details></li><li class=\"toggle\"><details><summary>Static properties</summary><ol><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/displayName\"><code>Function: displayName</code></a><abbr class=\"icon icon-nonstandard\" title=\"Non-standard. Check cross-browser support before using.\">\n<span class=\"visually-hidden\">Non-standard</span>\n</abbr></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/length\"><code>Function: length</code></a></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name\"><code>Function: name</code></a></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/prototype\"><code>Function: prototype</code></a></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/arguments\"><code>Function.prototype.arguments</code></a><abbr class=\"icon icon-nonstandard\" title=\"Non-standard. Check cross-browser support before using.\">\n<span class=\"visually-hidden\">Non-standard</span>\n</abbr><abbr class=\"icon icon-deprecated\" title=\"Deprecated. Not for use in new websites.\">\n<span class=\"visually-hidden\">Deprecated</span>\n</abbr></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/caller\"><code>Function.prototype.caller</code></a><abbr class=\"icon icon-nonstandard\" title=\"Non-standard. Check cross-browser support before using.\">\n<span class=\"visually-hidden\">Non-standard</span>\n</abbr><abbr class=\"icon icon-deprecated\" title=\"Deprecated. Not for use in new websites.\">\n<span class=\"visually-hidden\">Deprecated</span>\n</abbr></li></ol></details></li><li class=\"toggle\"><details><summary>Instance methods</summary><ol><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/__defineGetter__\"><code>Object.prototype.__defineGetter__()</code></a><abbr class=\"icon icon-deprecated\" title=\"Deprecated. Not for use in new websites.\">\n<span class=\"visually-hidden\">Deprecated</span>\n</abbr></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/__defineSetter__\"><code>Object.prototype.__defineSetter__()</code></a><abbr class=\"icon icon-deprecated\" title=\"Deprecated. Not for use in new websites.\">\n<span class=\"visually-hidden\">Deprecated</span>\n</abbr></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/__lookupGetter__\"><code>Object.prototype.__lookupGetter__()</code></a><abbr class=\"icon icon-deprecated\" title=\"Deprecated. Not for use in new websites.\">\n<span class=\"visually-hidden\">Deprecated</span>\n</abbr></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/__lookupSetter__\"><code>Object.prototype.__lookupSetter__()</code></a><abbr class=\"icon icon-deprecated\" title=\"Deprecated. Not for use in new websites.\">\n<span class=\"visually-hidden\">Deprecated</span>\n</abbr></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty\"><code>Object.prototype.hasOwnProperty()</code></a></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isPrototypeOf\"><code>Object.prototype.isPrototypeOf()</code></a></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/propertyIsEnumerable\"><code>Object.prototype.propertyIsEnumerable()</code></a></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/toLocaleString\"><code>Object.prototype.toLocaleString()</code></a></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/toString\"><code>Object.prototype.toString()</code></a></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/valueOf\"><code>Object.prototype.valueOf()</code></a></li></ol></details></li><li class=\"toggle\"><details><summary>Instance properties</summary><ol><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/proto\"><code>Object.prototype.__proto__</code></a><abbr class=\"icon icon-deprecated\" title=\"Deprecated. Not for use in new websites.\">\n<span class=\"visually-hidden\">Deprecated</span>\n</abbr></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/constructor\"><code>Object.prototype.constructor</code></a></li></ol></details></li></ol>","source":{"folder":"en-us/web/javascript/reference/global_objects/weakmap","github_url":"https://github.com/mdn/content/blob/main/files/en-us/web/javascript/reference/global_objects/weakmap/index.md","last_commit_url":"https://github.com/mdn/content/commit/4d150067b98ab6e79e6f6b0bf8343ae3ebd2b641","filename":"index.md"},"summary":"A WeakMap is a collection of key/value pairs whose keys must be objects or non-registered symbols, with values of any arbitrary JavaScript type, and which does not create strong references to its keys. That is, an object's presence as a key in a WeakMap does not prevent the object from being garbage collected. Once an object used as a key has been collected, its corresponding values in any WeakMap become candidates for garbage collection as well — as long as they aren't strongly referred to elsewhere. The only primitive type that can be used as a WeakMap key is symbol — more specifically, non-registered symbols — because non-registered symbols are guaranteed to be unique and cannot be re-created.","title":"WeakMap","toc":[{"text":"Description","id":"description"},{"text":"Constructor","id":"constructor"},{"text":"Instance properties","id":"instance_properties"},{"text":"Instance methods","id":"instance_methods"},{"text":"Examples","id":"examples"},{"text":"Specifications","id":"specifications"},{"text":"Browser compatibility","id":"browser_compatibility"},{"text":"See also","id":"see_also"}],"baseline":{"baseline":"high","baseline_low_date":"2015-07-29","baseline_high_date":"2018-01-29","support":{"chrome":"36","chrome_android":"36","edge":"12","firefox":"6","firefox_android":"6","safari":"8","safari_ios":"8"},"asterisk":true},"browserCompat":["javascript.builtins.WeakMap"],"pageType":"javascript-class"}}</script>

</body><!-- Mirrored from developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 08 Jan 2025 13:06:15 GMT --></html>