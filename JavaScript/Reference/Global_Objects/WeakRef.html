<!DOCTYPE html><html lang="en-US" prefix="og: https://ogp.me/ns#"><!-- Mirrored from developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakRef by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 08 Jan 2025 13:06:16 GMT --><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="icon" href="https://developer.mozilla.org/favicon-48x48.bc390275e955dacb2e65.png"><link rel="apple-touch-icon" href="https://developer.mozilla.org/apple-touch-icon.528534bba673c38049c2.png"><meta name="theme-color" content="#ffffff"><link rel="manifest" href="https://developer.mozilla.org/manifest.f42880861b394dd4dc9b.json"><link rel="search" type="application/opensearchdescription+xml" href="https://developer.mozilla.org/opensearch.xml" title="MDN Web Docs"><title>WeakRef</title><link rel="alternate" title="WeakRef" href="https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/WeakRef" hreflang="de"><link rel="alternate" title="WeakRef" href="https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Global_Objects/WeakRef" hreflang="fr"><link rel="alternate" title="WeakRef" href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/WeakRef" hreflang="ja"><link rel="alternate" title="WeakRef" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/WeakRef" hreflang="zh"><link rel="alternate" title="WeakRef" href="WeakRef.html" hreflang="en"><link rel="preload" as="font" type="font/woff2" href="https://developer.mozilla.org/static/media/Inter.var.c2fe3cb2b7c746f7966a.woff2" crossorigin=""><link rel="alternate" type="application/rss+xml" title="MDN Blog RSS Feed" href="https://developer.mozilla.org/en-US/blog/rss.xml" hreflang="en"><meta name="description" content="A WeakRef object lets you hold a weak reference to another object, without preventing that object from getting garbage-collected."><meta property="og:url" content="WeakRef.html"><meta property="og:title" content="WeakRef - JavaScript | MDN"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:description" content="A WeakRef object lets you hold a weak reference to another object, without preventing that object from getting garbage-collected."><meta property="og:image" content="https://developer.mozilla.org/mdn-social-share.d893525a4fb5fb1f67a2.png"><meta property="og:image:type" content="image/png"><meta property="og:image:height" content="1080"><meta property="og:image:width" content="1920"><meta property="og:image:alt" content="The MDN Web Docs logo, featuring a blue accent color, displayed on a solid black background."><meta property="og:site_name" content="MDN Web Docs"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:creator" content="MozDevNet"><link rel="canonical" href="WeakRef.html"><style media="print">.article-actions-container,.document-toc-container,.language-menu,.main-menu-toggle,.on-github,.page-footer,.place,.sidebar,.top-banner,.top-navigation-main,ul.prev-next{display:none!important}.main-page-content,.main-page-content pre{padding:2px}.main-page-content pre{border-left-width:2px}</style><link href="https://developer.mozilla.org/static/css/main.65aa8eed.css" rel="stylesheet"></head><body><script>if(document.body.addEventListener("load",(t=>{t.target.classList.contains("interactive")&&t.target.setAttribute("data-readystate","complete")}),{capture:!0}),window&&document.documentElement){const t={light:"#ffffff",dark:"#1b1b1b"};try{const e=window.localStorage.getItem("theme");e&&(document.documentElement.className=e,document.documentElement.style.backgroundColor=t[e]);const o=window.localStorage.getItem("nop");o&&(document.documentElement.dataset.nop=o)}catch(t){console.warn("Unable to read theme from localStorage",t)}}</script><div id="root"><div class="page-wrapper  category-javascript document-page"><div class="main-wrapper"><main id="content" class="main-content  "><article class="main-page-content" lang="en-US"><header><h1>WeakRef</h1><details class="baseline-indicator high"><summary><span class="indicator" role="img" aria-label="Baseline Check"></span><h2>Baseline<!-- --> <span class="not-bold">Widely available</span></h2><div class="browsers"><span class="engine" title="Supported in Chrome and Edge"><span class="browser chrome supported" role="img" aria-label="Chrome check"></span><span class="browser edge supported" role="img" aria-label="Edge check"></span></span><span class="engine" title="Supported in Firefox"><span class="browser firefox supported" role="img" aria-label="Firefox check"></span></span><span class="engine" title="Supported in Safari"><span class="browser safari supported" role="img" aria-label="Safari check"></span></span></div><span class="icon icon-chevron "></span></summary><div class="extra"><p>This feature is well established and works across many devices and browser versions. It’s been available across browsers since<!-- --> <!-- -->April 2021<!-- -->.</p><ul><li><a href="https://developer.mozilla.org/en-US/docs/Glossary/Baseline/Compatibility" data-glean="baseline_link_learn_more" target="_blank" class="learn-more">Learn more</a></li><li><a href="#browser_compatibility" data-glean="baseline_link_bcd_table">See full compatibility</a></li><li><a href="https://survey.alchemer.com/s3/7634825/MDN-baseline-feedback?page=%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FWeakRef&amp;level=high" data-glean="baseline_link_feedback" class="feedback-link" target="_blank" rel="noreferrer">Report feedback</a></li></ul></div></details></header><div class="section-content"><p>A <strong><code>WeakRef</code></strong> object lets you hold a weak reference to another object, without preventing that object from getting garbage-collected.</p></div><section aria-labelledby="description"><h2 id="description"><a href="#description">Description</a></h2><div class="section-content"><p>A <code>WeakRef</code> object contains a weak reference to an object, which is called its <em>target</em> or <em>referent</em>. A <em>weak reference</em> to an object is a reference that does not prevent the object from being reclaimed by the garbage collector. In contrast, a normal (or <em>strong</em>) reference keeps an object in memory. When an object no longer has any strong references to it, the JavaScript engine's garbage collector may destroy the object and reclaim its memory. If that happens, you can't get the object from a weak reference anymore.</p>
<p>Because <a href="Symbol.html#shared_symbols_in_the_global_symbol_registry">non-registered symbols</a> are also garbage collectable, they can also be used as the target of a <code>WeakRef</code> object. However, the use case of this is limited.</p></div></section><section aria-labelledby="avoid_where_possible"><h3 id="avoid_where_possible"><a href="#avoid_where_possible">Avoid where possible</a></h3><div class="section-content"><p>Correct use of <code>WeakRef</code> takes careful thought, and it's best avoided if possible. It's also important to avoid relying on any specific behaviors not guaranteed by the specification. When, how, and whether garbage collection occurs is down to the implementation of any given JavaScript engine. Any behavior you observe in one engine may be different in another engine, in another version of the same engine, or even in a slightly different situation with the same version of the same engine. Garbage collection is a hard problem that JavaScript engine implementers are constantly refining and improving their solutions to.</p>
<p>Here are some specific points included by the authors in the <a href="https://github.com/tc39/proposal-weakrefs" class="external" target="_blank">proposal</a> that introduced <code>WeakRef</code>:</p>
<blockquote>
<p><a href="https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)" class="external" target="_blank">Garbage collectors</a> are complicated. If an application or library depends on GC cleaning up a WeakRef or calling a finalizer [cleanup callback] in a timely, predictable manner, it's likely to be disappointed: the cleanup may happen much later than expected, or not at all. Sources of variability include:</p>
<ul>
<li>One object might be garbage-collected much sooner than another object, even if they become unreachable at the same time, e.g., due to generational collection.</li>
<li>Garbage collection work can be split up over time using incremental and concurrent techniques.</li>
<li>Various runtime heuristics can be used to balance memory usage, responsiveness.</li>
<li>The JavaScript engine may hold references to things which look like they are unreachable (e.g., in closures, or inline caches).</li>
<li>Different JavaScript engines may do these things differently, or the same engine may change its algorithms across versions.</li>
<li>Complex factors may lead to objects being held alive for unexpected amounts of time, such as use with certain APIs.</li>
</ul>
</blockquote></div></section><section aria-labelledby="notes_on_weakrefs"><h3 id="notes_on_weakrefs"><a href="#notes_on_weakrefs">Notes on WeakRefs</a></h3><div class="section-content"><ul>
<li>If your code has just created a <code>WeakRef</code> for a target object, or has gotten a target object from a <code>WeakRef</code>'s <code>deref</code> method, that target object will not be reclaimed until the end of the current JavaScript <a href="https://tc39.es/ecma262/multipage/executable-code-and-execution-contexts.html#job" class="external" target="_blank">job</a> (including any promise reaction jobs that run at the end of a script job). That is, you can only "see" an object get reclaimed between turns of the event loop. This is primarily to avoid making the behavior of any given JavaScript engine's garbage collector apparent in code — because if it were, people would write code relying on that behavior, which would break when the garbage collector's behavior changed. (Garbage collection is a hard problem; JavaScript engine implementers are constantly refining and improving how it works.)</li>
<li>If multiple <code>WeakRef</code>s have the same target, they're consistent with one another. The result of calling <code>deref</code> on one of them will match the result of calling <code>deref</code> on another of them (in the same job), you won't get the target object from one of them but <code>undefined</code> from another.</li>
<li>If the target of a <code>WeakRef</code> is also in a <a href="FinalizationRegistry.html"><code>FinalizationRegistry</code></a>, the <code>WeakRef</code>'s target is cleared at the same time or before any cleanup callback associated with the registry is called; if your cleanup callback calls <code>deref</code> on a <code>WeakRef</code> for the object, it will receive <code>undefined</code>.</li>
<li>You cannot change the target of a <code>WeakRef</code>, it will always only ever be the original target object or <code>undefined</code> when that target has been reclaimed.</li>
<li>A <code>WeakRef</code> might never return <code>undefined</code> from <code>deref</code>, even if nothing strongly holds the target, because the garbage collector may never decide to reclaim the object.</li>
</ul></div></section><section aria-labelledby="constructor"><h2 id="constructor"><a href="#constructor">Constructor</a></h2><div class="section-content"><dl>
<dt id="weakref"><a href="WeakRef/WeakRef.html"><code>WeakRef()</code></a></dt>
<dd>
<p>Creates a new <code>WeakRef</code> object.</p>
</dd>
</dl></div></section><section aria-labelledby="instance_properties"><h2 id="instance_properties"><a href="#instance_properties">Instance properties</a></h2><div class="section-content"><p>These properties are defined on <code>WeakRef.prototype</code> and shared by all <code>WeakRef</code> instances.</p>
<dl>
<dt id="weakref.prototype.constructor"><a href="Object/constructor.html"><code>WeakRef.prototype.constructor</code></a> <span class="badge inline optional">Optional</span></dt>
<dd>
<p>The constructor function that created the instance object. For <code>WeakRef</code> instances, the initial value is the <a href="WeakRef/WeakRef.html"><code>WeakRef</code></a> constructor.</p>
<div class="notecard note">
<p><strong>Note:</strong>
This property is marked as "normative optional" in the specification, which means a conforming implementation may not expose the <code>constructor</code> property. This prevents arbitrary code from obtaining the <code>WeakRef</code> constructor and being able to observe garbage collection. However, all major engines do expose it by default.</p>
</div>
</dd>
<dt id="weakref.prototypesymbol.tostringtag"><a href="#weakref.prototypesymbol.tostringtag"><code>WeakRef.prototype[Symbol.toStringTag]</code></a></dt>
<dd>
<p>The initial value of the <a href="Symbol/toStringTag.html"><code>[Symbol.toStringTag]</code></a> property is the string <code>"WeakRef"</code>. This property is used in <a href="Object/toString.html"><code>Object.prototype.toString()</code></a>.</p>
</dd>
</dl></div></section><section aria-labelledby="instance_methods"><h2 id="instance_methods"><a href="#instance_methods">Instance methods</a></h2><div class="section-content"><dl>
<dt id="weakref.prototype.deref"><a href="WeakRef/deref.html"><code>WeakRef.prototype.deref()</code></a></dt>
<dd>
<p>Returns the <code>WeakRef</code> object's target object, or <code>undefined</code> if the target object has been reclaimed.</p>
</dd>
</dl></div></section><section aria-labelledby="examples"><h2 id="examples"><a href="#examples">Examples</a></h2><div class="section-content"></div></section><section aria-labelledby="using_a_weakref_object"><h3 id="using_a_weakref_object"><a href="#using_a_weakref_object">Using a WeakRef object</a></h3><div class="section-content"><p>This example starts a counter shown in a DOM element, stopping when the element doesn't exist anymore:</p>
<div class="code-example"><div class="example-header"><span class="language-name">js</span></div><pre class="brush: js notranslate"><code>class Counter {
  constructor(element) {
    // Remember a weak reference to the DOM element
    this.ref = new WeakRef(element);
    this.start();
  }

  start() {
    if (this.timer) {
      return;
    }

    this.count = 0;

    const tick = () =&gt; {
      // Get the element from the weak reference, if it still exists
      const element = this.ref.deref();
      if (element) {
        element.textContent = ++this.count;
      } else {
        // The element doesn't exist anymore
        console.log("The element is gone.");
        this.stop();
        this.ref = null;
      }
    };

    tick();
    this.timer = setInterval(tick, 1000);
  }

  stop() {
    if (this.timer) {
      clearInterval(this.timer);
      this.timer = 0;
    }
  }
}

const counter = new Counter(document.getElementById("counter"));
setTimeout(() =&gt; {
  document.getElementById("counter").remove();
}, 5000);
</code></pre></div></div></section><h2 id="specifications"><a href="#specifications">Specifications</a></h2><table class="standard-table"><thead><tr><th scope="col">Specification</th></tr></thead><tbody><tr><td><a href="https://tc39.es/ecma262/multipage/managing-memory.html#sec-weak-ref-objects">ECMAScript Language Specification<!-- --> <br><small># <!-- -->sec-weak-ref-objects</small></a></td></tr></tbody></table><h2 id="browser_compatibility"><a href="#browser_compatibility">Browser compatibility</a></h2><p>BCD tables only load in the browser<noscript> <!-- -->with JavaScript enabled. Enable JavaScript to view data.</noscript></p><section aria-labelledby="see_also"><h2 id="see_also"><a href="#see_also">See also</a></h2><div class="section-content"><ul>
<li><a href="FinalizationRegistry.html"><code>FinalizationRegistry</code></a></li>
<li><a href="WeakSet.html"><code>WeakSet</code></a></li>
<li><a href="WeakMap.html"><code>WeakMap</code></a></li>
</ul></div></section></article></main></div></div></div><script type="application/json" id="hydration">{"url":"/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakRef","doc":{"body":[{"type":"prose","value":{"id":null,"title":null,"isH3":false,"content":"<p>A <strong><code>WeakRef</code></strong> object lets you hold a weak reference to another object, without preventing that object from getting garbage-collected.</p>"}},{"type":"prose","value":{"id":"description","title":"Description","isH3":false,"content":"<p>A <code>WeakRef</code> object contains a weak reference to an object, which is called its <em>target</em> or <em>referent</em>. A <em>weak reference</em> to an object is a reference that does not prevent the object from being reclaimed by the garbage collector. In contrast, a normal (or <em>strong</em>) reference keeps an object in memory. When an object no longer has any strong references to it, the JavaScript engine's garbage collector may destroy the object and reclaim its memory. If that happens, you can't get the object from a weak reference anymore.</p>\n<p>Because <a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol#shared_symbols_in_the_global_symbol_registry\">non-registered symbols</a> are also garbage collectable, they can also be used as the target of a <code>WeakRef</code> object. However, the use case of this is limited.</p>"}},{"type":"prose","value":{"id":"avoid_where_possible","title":"Avoid where possible","isH3":true,"content":"<p>Correct use of <code>WeakRef</code> takes careful thought, and it's best avoided if possible. It's also important to avoid relying on any specific behaviors not guaranteed by the specification. When, how, and whether garbage collection occurs is down to the implementation of any given JavaScript engine. Any behavior you observe in one engine may be different in another engine, in another version of the same engine, or even in a slightly different situation with the same version of the same engine. Garbage collection is a hard problem that JavaScript engine implementers are constantly refining and improving their solutions to.</p>\n<p>Here are some specific points included by the authors in the <a href=\"https://github.com/tc39/proposal-weakrefs\" class=\"external\" target=\"_blank\">proposal</a> that introduced <code>WeakRef</code>:</p>\n<blockquote>\n<p><a href=\"https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)\" class=\"external\" target=\"_blank\">Garbage collectors</a> are complicated. If an application or library depends on GC cleaning up a WeakRef or calling a finalizer [cleanup callback] in a timely, predictable manner, it's likely to be disappointed: the cleanup may happen much later than expected, or not at all. Sources of variability include:</p>\n<ul>\n<li>One object might be garbage-collected much sooner than another object, even if they become unreachable at the same time, e.g., due to generational collection.</li>\n<li>Garbage collection work can be split up over time using incremental and concurrent techniques.</li>\n<li>Various runtime heuristics can be used to balance memory usage, responsiveness.</li>\n<li>The JavaScript engine may hold references to things which look like they are unreachable (e.g., in closures, or inline caches).</li>\n<li>Different JavaScript engines may do these things differently, or the same engine may change its algorithms across versions.</li>\n<li>Complex factors may lead to objects being held alive for unexpected amounts of time, such as use with certain APIs.</li>\n</ul>\n</blockquote>"}},{"type":"prose","value":{"id":"notes_on_weakrefs","title":"Notes on WeakRefs","isH3":true,"content":"<ul>\n<li>If your code has just created a <code>WeakRef</code> for a target object, or has gotten a target object from a <code>WeakRef</code>'s <code>deref</code> method, that target object will not be reclaimed until the end of the current JavaScript <a href=\"https://tc39.es/ecma262/multipage/executable-code-and-execution-contexts.html#job\" class=\"external\" target=\"_blank\">job</a> (including any promise reaction jobs that run at the end of a script job). That is, you can only \"see\" an object get reclaimed between turns of the event loop. This is primarily to avoid making the behavior of any given JavaScript engine's garbage collector apparent in code — because if it were, people would write code relying on that behavior, which would break when the garbage collector's behavior changed. (Garbage collection is a hard problem; JavaScript engine implementers are constantly refining and improving how it works.)</li>\n<li>If multiple <code>WeakRef</code>s have the same target, they're consistent with one another. The result of calling <code>deref</code> on one of them will match the result of calling <code>deref</code> on another of them (in the same job), you won't get the target object from one of them but <code>undefined</code> from another.</li>\n<li>If the target of a <code>WeakRef</code> is also in a <a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/FinalizationRegistry\"><code>FinalizationRegistry</code></a>, the <code>WeakRef</code>'s target is cleared at the same time or before any cleanup callback associated with the registry is called; if your cleanup callback calls <code>deref</code> on a <code>WeakRef</code> for the object, it will receive <code>undefined</code>.</li>\n<li>You cannot change the target of a <code>WeakRef</code>, it will always only ever be the original target object or <code>undefined</code> when that target has been reclaimed.</li>\n<li>A <code>WeakRef</code> might never return <code>undefined</code> from <code>deref</code>, even if nothing strongly holds the target, because the garbage collector may never decide to reclaim the object.</li>\n</ul>"}},{"type":"prose","value":{"id":"constructor","title":"Constructor","isH3":false,"content":"<dl>\n<dt id=\"weakref\"><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakRef/WeakRef\"><code>WeakRef()</code></a></dt>\n<dd>\n<p>Creates a new <code>WeakRef</code> object.</p>\n</dd>\n</dl>"}},{"type":"prose","value":{"id":"instance_properties","title":"Instance properties","isH3":false,"content":"<p>These properties are defined on <code>WeakRef.prototype</code> and shared by all <code>WeakRef</code> instances.</p>\n<dl>\n<dt id=\"weakref.prototype.constructor\"><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/constructor\"><code>WeakRef.prototype.constructor</code></a> <span class=\"badge inline optional\">Optional</span></dt>\n<dd>\n<p>The constructor function that created the instance object. For <code>WeakRef</code> instances, the initial value is the <a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakRef/WeakRef\"><code>WeakRef</code></a> constructor.</p>\n<div class=\"notecard note\">\n<p><strong>Note:</strong>\nThis property is marked as \"normative optional\" in the specification, which means a conforming implementation may not expose the <code>constructor</code> property. This prevents arbitrary code from obtaining the <code>WeakRef</code> constructor and being able to observe garbage collection. However, all major engines do expose it by default.</p>\n</div>\n</dd>\n<dt id=\"weakref.prototypesymbol.tostringtag\"><a href=\"#weakref.prototypesymbol.tostringtag\"><code>WeakRef.prototype[Symbol.toStringTag]</code></a></dt>\n<dd>\n<p>The initial value of the <a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/toStringTag\"><code>[Symbol.toStringTag]</code></a> property is the string <code>\"WeakRef\"</code>. This property is used in <a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/toString\"><code>Object.prototype.toString()</code></a>.</p>\n</dd>\n</dl>"}},{"type":"prose","value":{"id":"instance_methods","title":"Instance methods","isH3":false,"content":"<dl>\n<dt id=\"weakref.prototype.deref\"><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakRef/deref\"><code>WeakRef.prototype.deref()</code></a></dt>\n<dd>\n<p>Returns the <code>WeakRef</code> object's target object, or <code>undefined</code> if the target object has been reclaimed.</p>\n</dd>\n</dl>"}},{"type":"prose","value":{"id":"examples","title":"Examples","isH3":false,"content":""}},{"type":"prose","value":{"id":"using_a_weakref_object","title":"Using a WeakRef object","isH3":true,"content":"<p>This example starts a counter shown in a DOM element, stopping when the element doesn't exist anymore:</p>\n<div class=\"code-example\"><div class=\"example-header\"><span class=\"language-name\">js</span></div><pre class=\"brush: js notranslate\"><code>class Counter {\n  constructor(element) {\n    // Remember a weak reference to the DOM element\n    this.ref = new WeakRef(element);\n    this.start();\n  }\n\n  start() {\n    if (this.timer) {\n      return;\n    }\n\n    this.count = 0;\n\n    const tick = () =&gt; {\n      // Get the element from the weak reference, if it still exists\n      const element = this.ref.deref();\n      if (element) {\n        element.textContent = ++this.count;\n      } else {\n        // The element doesn't exist anymore\n        console.log(\"The element is gone.\");\n        this.stop();\n        this.ref = null;\n      }\n    };\n\n    tick();\n    this.timer = setInterval(tick, 1000);\n  }\n\n  stop() {\n    if (this.timer) {\n      clearInterval(this.timer);\n      this.timer = 0;\n    }\n  }\n}\n\nconst counter = new Counter(document.getElementById(\"counter\"));\nsetTimeout(() =&gt; {\n  document.getElementById(\"counter\").remove();\n}, 5000);\n</code></pre></div>"}},{"type":"specifications","value":{"id":"specifications","title":"Specifications","isH3":false,"specifications":[{"bcdSpecificationURL":"https://tc39.es/ecma262/multipage/managing-memory.html#sec-weak-ref-objects","title":"ECMAScript Language Specification"}],"query":"javascript.builtins.WeakRef"}},{"type":"browser_compatibility","value":{"id":"browser_compatibility","title":"Browser compatibility","isH3":false,"query":"javascript.builtins.WeakRef"}},{"type":"prose","value":{"id":"see_also","title":"See also","isH3":false,"content":"<ul>\n<li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/FinalizationRegistry\"><code>FinalizationRegistry</code></a></li>\n<li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakSet\"><code>WeakSet</code></a></li>\n<li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap\"><code>WeakMap</code></a></li>\n</ul>"}}],"isActive":true,"isMarkdown":true,"isTranslated":false,"locale":"en-US","mdn_url":"/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakRef","modified":"2024-07-26T02:23:10.000Z","native":"English (US)","noIndexing":false,"other_translations":[{"locale":"de","title":"WeakRef","native":"Deutsch"},{"locale":"fr","title":"WeakRef","native":"Français"},{"locale":"ja","title":"WeakRef","native":"日本語"},{"locale":"zh-CN","title":"WeakRef","native":"中文 (简体)"}],"pageTitle":"WeakRef - JavaScript | MDN","parents":[{"uri":"/en-US/docs/Web","title":"References"},{"uri":"/en-US/docs/Web/JavaScript","title":"JavaScript"},{"uri":"/en-US/docs/Web/JavaScript/Reference","title":"Reference"},{"uri":"/en-US/docs/Web/JavaScript/Reference/Global_Objects","title":"Standard built-in objects"},{"uri":"/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakRef","title":"WeakRef"}],"popularity":null,"short_title":"WeakRef","sidebarHTML":"<ol><li class=\"section\"><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects\">Standard built-in objects</a></li><li class=\"section\"><em><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakRef\" aria-current=\"page\"><code>WeakRef</code></a></em></li><li class=\"toggle\"><details open=\"\"><summary>Constructor</summary><ol><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakRef/WeakRef\"><code>WeakRef() constructor</code></a></li></ol></details></li><li class=\"toggle\"><details open=\"\"><summary>Instance methods</summary><ol><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakRef/deref\"><code>WeakRef.prototype.deref()</code></a></li></ol></details></li><li class=\"section\">Inheritance</li><li class=\"section\"><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object\"><code>Object/Function</code></a></li><li class=\"toggle\"><details><summary>Static methods</summary><ol><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply\"><code>Function.prototype.apply()</code></a></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind\"><code>Function.prototype.bind()</code></a></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call\"><code>Function.prototype.call()</code></a></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/toString\"><code>Function.prototype.toString()</code></a></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/Symbol.hasInstance\"><code>Function.prototype[Symbol.hasInstance]()</code></a></li></ol></details></li><li class=\"toggle\"><details><summary>Static properties</summary><ol><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/displayName\"><code>Function: displayName</code></a><abbr class=\"icon icon-nonstandard\" title=\"Non-standard. Check cross-browser support before using.\">\n<span class=\"visually-hidden\">Non-standard</span>\n</abbr></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/length\"><code>Function: length</code></a></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name\"><code>Function: name</code></a></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/prototype\"><code>Function: prototype</code></a></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/arguments\"><code>Function.prototype.arguments</code></a><abbr class=\"icon icon-nonstandard\" title=\"Non-standard. Check cross-browser support before using.\">\n<span class=\"visually-hidden\">Non-standard</span>\n</abbr><abbr class=\"icon icon-deprecated\" title=\"Deprecated. Not for use in new websites.\">\n<span class=\"visually-hidden\">Deprecated</span>\n</abbr></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/caller\"><code>Function.prototype.caller</code></a><abbr class=\"icon icon-nonstandard\" title=\"Non-standard. Check cross-browser support before using.\">\n<span class=\"visually-hidden\">Non-standard</span>\n</abbr><abbr class=\"icon icon-deprecated\" title=\"Deprecated. Not for use in new websites.\">\n<span class=\"visually-hidden\">Deprecated</span>\n</abbr></li></ol></details></li><li class=\"toggle\"><details><summary>Instance methods</summary><ol><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/__defineGetter__\"><code>Object.prototype.__defineGetter__()</code></a><abbr class=\"icon icon-deprecated\" title=\"Deprecated. Not for use in new websites.\">\n<span class=\"visually-hidden\">Deprecated</span>\n</abbr></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/__defineSetter__\"><code>Object.prototype.__defineSetter__()</code></a><abbr class=\"icon icon-deprecated\" title=\"Deprecated. Not for use in new websites.\">\n<span class=\"visually-hidden\">Deprecated</span>\n</abbr></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/__lookupGetter__\"><code>Object.prototype.__lookupGetter__()</code></a><abbr class=\"icon icon-deprecated\" title=\"Deprecated. Not for use in new websites.\">\n<span class=\"visually-hidden\">Deprecated</span>\n</abbr></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/__lookupSetter__\"><code>Object.prototype.__lookupSetter__()</code></a><abbr class=\"icon icon-deprecated\" title=\"Deprecated. Not for use in new websites.\">\n<span class=\"visually-hidden\">Deprecated</span>\n</abbr></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty\"><code>Object.prototype.hasOwnProperty()</code></a></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isPrototypeOf\"><code>Object.prototype.isPrototypeOf()</code></a></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/propertyIsEnumerable\"><code>Object.prototype.propertyIsEnumerable()</code></a></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/toLocaleString\"><code>Object.prototype.toLocaleString()</code></a></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/toString\"><code>Object.prototype.toString()</code></a></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/valueOf\"><code>Object.prototype.valueOf()</code></a></li></ol></details></li><li class=\"toggle\"><details><summary>Instance properties</summary><ol><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/proto\"><code>Object.prototype.__proto__</code></a><abbr class=\"icon icon-deprecated\" title=\"Deprecated. Not for use in new websites.\">\n<span class=\"visually-hidden\">Deprecated</span>\n</abbr></li><li><a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/constructor\"><code>Object.prototype.constructor</code></a></li></ol></details></li></ol>","source":{"folder":"en-us/web/javascript/reference/global_objects/weakref","github_url":"https://github.com/mdn/content/blob/main/files/en-us/web/javascript/reference/global_objects/weakref/index.md","last_commit_url":"https://github.com/mdn/content/commit/5c000c8621145c6915f3d545b505c216317bc64a","filename":"index.md"},"summary":"A WeakRef object lets you hold a weak reference to another object, without preventing that object from getting garbage-collected.","title":"WeakRef","toc":[{"text":"Description","id":"description"},{"text":"Constructor","id":"constructor"},{"text":"Instance properties","id":"instance_properties"},{"text":"Instance methods","id":"instance_methods"},{"text":"Examples","id":"examples"},{"text":"Specifications","id":"specifications"},{"text":"Browser compatibility","id":"browser_compatibility"},{"text":"See also","id":"see_also"}],"baseline":{"baseline":"high","baseline_low_date":"2021-04-26","baseline_high_date":"2023-10-26","support":{"chrome":"84","chrome_android":"84","edge":"84","firefox":"79","firefox_android":"79","safari":"14.1","safari_ios":"14.5"},"asterisk":true},"browserCompat":["javascript.builtins.WeakRef"],"pageType":"javascript-class"}}</script>

</body><!-- Mirrored from developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakRef by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 08 Jan 2025 13:06:17 GMT --></html>